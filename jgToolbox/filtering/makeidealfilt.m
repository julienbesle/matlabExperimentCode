function [The_Filter] = makeidealfilt(Image_Size,InRadius,OutRadius,DC)% function [The_Filter] = makeidealfilt(Image_Size,InRadius,OutRadius,DC)%% This m-file creates a 2D ideal bandpass filter in the Fourier domain. % DC is 0 if not specified. Usually it would be 1 otherwise.% The matrix is assumed to be square of size Image_Size x Image_Size.% INRADIUS is the lower cutoff frequency, OUTRADIUS the upper cut-off freq.% INRADIUS and OUTRADIUS can be even or odd. The center of the filter% is considered to be Image_Size/2+1,Image_Size/2+1.% Image_Size should be an even number.%% October 17, 1997.  JMG ABS PJB  U of T Vision Lab% October 18, 1997.  JMG Made band-pass instead of low or high pass.% Default DC value.if ~exist('DC','var')	DC = 0;end% The final bandpass filter is made by taking the union of a HP and LP% filter that have the frequency limits specified by INRADIUS and OUTRADIUS.% We will do this by making 1/4 of the filter and then rotating/reflecting% the rest of the pieces.% First, make a filter to get rid of the energy beyond the nyquist limit.RadSq = round((Image_Size/2+1)^2);RadSqrt2 = round((Image_Size/2+1)/sqrt(2));Q4 = zeros(Image_Size/2+1,Image_Size/2+1);Q4(1:RadSqrt2,1:RadSqrt2) = ones(RadSqrt2,RadSqrt2);for i = 1:RadSqrt2	dist = round(sqrt(RadSq - i^2) - RadSqrt2);	if RadSqrt2 < RadSqrt2+dist		Q4(RadSqrt2:RadSqrt2+dist,i) =  1;		Q4(i,RadSqrt2:RadSqrt2+dist) =  1;	end	end% Now make the other pieces.Q2 = flipud(fliplr(Q4));Q3 = flipud(Q2);Q1 = fliplr(Q2);% Put them together.Nyquist_Filter = [Q2,Q1(:,2:Image_Size/2+1);Q3(2:Image_Size/2+1,:),Q4(2:Image_Size/2+1,2:Image_Size/2+1)];Nyquist_Filter = Nyquist_Filter(1:Image_Size,1:Image_Size);% Do the LP filter first.% Make the first 1/4 of the filter. This is called Q4 for "quadrant 4".if OutRadius < Image_Size/2+1	RadSq = round((OutRadius+1)^2);	RadSqrt2 = round((OutRadius+1)/sqrt(2));	Q4 = zeros(Image_Size/2+1,Image_Size/2+1);	Q4(1:RadSqrt2,1:RadSqrt2) = ones(RadSqrt2,RadSqrt2);	for i = 1:RadSqrt2		dist = round(sqrt(RadSq - i^2) - RadSqrt2);		if RadSqrt2 < RadSqrt2+dist			Q4(RadSqrt2:RadSqrt2+dist,i) =  1;			Q4(i,RadSqrt2:RadSqrt2+dist) =  1;		end		end	% Now make the other pieces.	Q2 = flipud(fliplr(Q4));	Q3 = flipud(Q2);	Q1 = fliplr(Q2);	% Put them together.	LP_Filter = [Q2,Q1(:,2:Image_Size/2+1);Q3(2:Image_Size/2+1,:),Q4(2:Image_Size/2+1,2:Image_Size/2+1)];	LP_Filter = LP_Filter(1:Image_Size,1:Image_Size);	else	LP_Filter = ones(Image_Size);end% If the inner region is zero (LP), just use the filter made above. % Otherwise, make a HP filter to create the final bandpass filter.if InRadius > 0	RadSq = round(InRadius^2);	RadSqrt2 = round(InRadius/sqrt(2));	Q4 = zeros(Image_Size/2+1,Image_Size/2+1);	Q4(1:RadSqrt2,1:RadSqrt2) = ones(RadSqrt2,RadSqrt2);	for i = 1:RadSqrt2		dist = round(sqrt(RadSq - i^2) - RadSqrt2);		if RadSqrt2 < RadSqrt2+dist			Q4(RadSqrt2:RadSqrt2+dist,i) =  1;			Q4(i,RadSqrt2:RadSqrt2+dist) =  1;		end		end	% Now make the other pieces.	Q2 = flipud(fliplr(Q4));	Q3 = flipud(Q2);	Q1 = fliplr(Q2);	% Put them together.	HP_Filter = [Q2,Q1(:,2:Image_Size/2+1);Q3(2:Image_Size/2+1,:),Q4(2:Image_Size/2+1,2:Image_Size/2+1)];	HP_Filter = abs(HP_Filter(1:Image_Size,1:Image_Size)-1);else	HP_Filter = ones(Image_Size);end% The final bandpass filter.The_Filter = LP_Filter.*HP_Filter.*Nyquist_Filter;% Set the DC component.The_Filter(Image_Size/2+1,Image_Size/2+1) = DC;% END.