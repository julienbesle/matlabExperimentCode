function theFilter = makegaussfilt(imageSize,CF,octaves,pass,DC)% function theFilter = makeGaussfilt(imageSize,CF,octaves,pass,DC)%% Make a LP, HP, or bandpass filter centered at 'CF' that is Gaussian% in shape in log frequency space. 'octaves' specifies the bandwidth% of the Gaussian. The distribution is at half of its amplitude at +/-% 'octaves'. 'DC' specifies the zero-frequency component (average% luminance/contrast). The default DC component attenuation value is zero.% N.B.: imageSize must be an even number. If it is not, the value is% decremented to the lower even number. If it is real, the number is% truncated. 'pass' is H if high-pass, L if low-pass, B if bandpass.% % JMG  Feb 16 1998  U of T Vision Lab% Set the DC component.if ~exist('DC','var')	DC = 0;end% Check to see if imageSize is even.imageSize = imageSize-rem(imageSize,2);% The point where the value of the gaussian is at half of its amplitude is% about 1.175 standard deviations. This is to be factored in by the factor below.% This may be found by the function GETGAUSS, where the mean = 0, sd = 1, and % invalue = 1.175. This will return a value of .2, which is half of the max% amplitude of .4.sdFactor = 1.175;% Compute the standard deviations of the distributions to make the % filter.sd = octaves/sdFactor;% Intialize the matrix. This is just the second quadrant of the filter.Q2 = zeros(imageSize/2+1,imageSize/2+1);pass=lower(pass);% Make the second quadrant of the filter.for i=1:imageSize/2+1	for j=1:imageSize/2+1		% This makes the bandwidth constant in octaves above and below the CF.		 radius = round(sqrt((imageSize/2+2-i).^2+(imageSize/2+2-j)^2));		if pass == 'b'			Q2(i,j) = (1/sqrt(2*pi)*sd).*exp(-(((log2(radius)-log2(CF))/sd)^2)/2);		elseif pass == 'h'			if radius < CF				Q2(i,j) = (1/sqrt(2*pi)*sd).*exp(-(((log2(radius)-log2(CF))/sd)^2)/2);			else				Q2(i,j) = (1/sqrt(2*pi)*sd).*exp(-(((log2(CF)-log2(CF))/sd)^2)/2);			end		elseif pass == 'l'			if radius > CF				Q2(i,j) = (1/sqrt(2*pi)*sd).*exp(-(((log2(radius)-log2(CF))/sd)^2)/2);			else				Q2(i,j) = (1/sqrt(2*pi)*sd).*exp(-(((log2(CF)-log2(CF))/sd)^2)/2);			end		end				% This works for a costant linear bandwidth above and below the CF.		% Q2(i,j) = (1/sqrt(2*pi)*sd)*exp(-(((radius-CF)/sd)^2)/2);					endend% Normalize the filter.%Q2 = (Q2-min(min(Q2)));%Q2 = Q2/max(max(Q2));% Now make the other pieces.Q3 = flipud(Q2);Q1 = fliplr(Q2);Q4 = flipud(Q1);% Put them together.theFilter = [Q2,Q1(:,1:imageSize/2);Q3(1:imageSize/2,:),Q4(1:imageSize/2,1:imageSize/2)];theFilter = theFilter(1:imageSize,1:imageSize);% Set the DC component.theFilter(imageSize/2+1,imageSize/2+1) = DC;return;