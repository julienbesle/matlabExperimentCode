function mtchtmp(name,stimtype,numstim,mainscrs,maxtrials,freq,approxthresh,numsessions,numstimlevels,octaves,nzvar,logrange,filtertemps,rotation)% mtchtmp(name,stimtype,numstim,mainscrs,maxtrials,freq,approxthresh,numsessions,numstimlevels,noisetype,rotation,octaves)%% finds thresholds in the noise masking experiment% uses method of constant stimuli% 'name' is the name the subject, in intials% 'stimtype' is the type of stimulus to be shown% ('f'=faces; 'l'=letters; 'g' = gratings) % default screen is 1. default number of trials is 40.%% Sept 18 1998  JMG  U of Toronto Vision Lab% the name of the file containing the initial thresholdif nargin > 2	% change directories to the main folder	cf;	jg feature;			% defaults	defarg('mainscrs',1);	defarg('maxtrials',35);	defarg('noiserange',[1e-4 .0625]);	defarg('numsessions',1);	defarg('numstimlevels',6);	defarg('nzvar',.2022);	defarg('rotation','');	defarg('octaves',2);	defarg('logrange',2);	defarg('filtertemps',1);		% estimate of lowest threshold	if strcmp(lower(stimtype(1)),'f')		defarg('approxthresh',7.5e-4);	else		defarg('approxthresh',2.5e-4);	end	% stimulus and noise levels	if ~exist('freq','var')		numfreq = 7;	else		numfreq = length(freq);	end	% the stimulus levels to test 	if ~exist('freq','var')		freq = logspace(log10(noiserange(1)),log10(noiserange(2)),numfreq);		end	% error checking	if length(approxthresh) < numfreq		printstr('number of conditions and threshold estimates do not match.');		break;	end	% constants	fileshareoff = 1;	calfile = 'AppleA.DDF';	duration = .5;	darktime = 120;	vd = 100;	basefixation = ones(4);	randfixation = basefixation*210;	% parameters for grating identification	gaborsz = 256;	gfreq = 4;	phz = 0;	deg1 = -45;	deg2 = deg1+90;	cpw = 2.5;			% make sounds	introsnd=makesnd(140,.2,.5);	corrsnd=makesnd(400,.09,.5);	wrongsnd=makesnd(200,.09,.5);		% open the screens	tempCLUT=ones(256,3)*160;	tempCLUT(2,:)=[1 1 1];	[screens,rects] = openscreens(mainscrs,tempCLUT);	[oldfont,oldsz,oldstyle] = settext(screens(1),'Times',26,1);	% load the stimuli & calibration files	[newx,newy] = centertext(screens(1),rects(1,:),'Pause For Adaptation'); tic;	% get the calibration data	[cal] = getddf(calfile);	% hide the cursor;	hidecursor;	% load the stimulus file. stimuli are stored in the structure 'images'.	if lower(stimtype(1)) == 'l'		load('LetterStruct');		names = fieldnames(images);	elseif lower(stimtype(1)) == 'f'		load('FaceStruct');		names = fieldnames(images);	elseif lower(stimtype(1)) == 'h'		load('HebrewStruct');		names = fieldnames(images);	elseif lower(stimtype(1)) == 't'		load('TPStruct');		names = fieldnames(images);	else		images.g1 = dogabor(gfreq,cpw,gaborsz,deg1,phz);		images.g2 = dogabor(gfreq,cpw,gaborsz,deg2,phz);		names = {'g1','g2'};	end	numstim = length(names);	eval(['imagesz = size(images.',names{1},');']);	nzsz = imagesz;				% rotation 	if strcmp(rotation,'rot')		for i = 1:numstim			eval(['images.',names{i},' = rot90(images.',names{i},',2);']);		end	end		% make file names	found = 0;	loc = 1;	while ~found		if numsessions > 1			filename = [name,num2str(loc),'mtchtemp',rotation,upper(stimtype(1)),num2str(numstim),'.dat'];		else			filename = [name,num2str(loc),'mtchtemp',rotation,upper(stimtype(1)),num2str(numstim),'.dat'];		end		if ~(exist(filename)==2)			found = 1;		else			loc = loc+1;		end	end		% the stimulus levels to test	for i=1:numfreq		if numstimlevels > 1			stimlevels(:,i) = logspace(log10(approxthresh(i)./10^(logrange/2)),log10(approxthresh(i).*10^(logrange/2)),numstimlevels)';		else			stimlevels(:,i) = approxthresh(i);		end	end		% open the data file and write the header	if exist(filename) ~= 2		fwid = fopen(filename,'a+');					savecomment(fwid,['Data File Name: ',filename]);		savecomment(fwid,'eqnoise experiment');		savecomment(fwid,['calibration file: ',calfile]);		savecomment(fwid,['image names: ',strcat(names{1:end})]);		if strcmp(lower(stimtype),'g')			savecommand(fwid,['orientations = [',num2str([deg1 deg2]),'];']);			savecommand(fwid,['cpi = ',num2str(gfreq),'; cpw = ',num2str(cpw),'; phase = ',num2str(phz),';']);		end		savecommand(fwid,['viewingdistance = ',num2str(vd),'; resolution = [',num2str(rects(1,3)),',',num2str(rects(4)),']; gam = ',num2str(1/numstim),';']);		savecommand(fwid,['stimtype = 'quotestring(stimtype),'; duration = ',num2str(duration),'; darktime = ',num2str(darktime),';trials = ',num2str(maxtrials),';']);		savecommand(fwid,'trial = 1; sequence = 2; response = 3; correct = 4; stimlevel = 5; condition = 6; randnstate1 = 7; randnstate2 = 8;');		savedatetime(fwid);	else		fwid = fopen(filename,'a+');					savedatetime(fwid);	end	% turn off filesharing	if fileshareoff		status=fs('Off');	end		% continue dark adptation	hidecursor;	done=toc;	togo=darktime-done;	passed=0;	start=GetSecs;	hit='9';	while getsecs-start < togo & abs(hit)~=48  	% zero key skips adaptation		if CharAvail			hit=getchar;		end	end		% initialize	sequence = rands([1:numstim],[1,maxtrials*numstimlevels*numfreq]);	conlevel = zeros(size(sequence));	id = zeros(size(sequence));		% for the responses	responses = zeros([length(sequence),numsessions]);	correct = responses;	counter = 1;	session = 1;	totaltrials = maxtrials*numstimlevels*numfreq*numsessions;	trial = 0;		% retain the unfiltered images	unfilteredimages = images;		% get the unfiltered maximum variance	cmax = min(abs([(cal.lmaxminave(1)-cal.lmaxminave(3))/cal.lmaxminave(3),(cal.lmaxminave(2)-cal.lmaxminave(3))/cal.lmaxminave(3)])); 	for j = 1:numstim		eval(['temp = images.',names{j},'*(cmax/max(max(abs(images.',names{j},'))));']);		vmax(j) = std(temp(:))^2;			end	unfiltbasevar = min(vmax);	% start the loop	for i = 1:numfreq			screen(screens(1),'FillRect',0);		flushevents('mouseUp','mouseDown');		[newx,newy] = centertext(screens(1),rects(1,:),'Making Stimuli...');		% the filter		filt = fftunshift(makeidealfilt(imagesz(1),freq(i)/(2^octaves),freq(i),0));		if freq(i) > 1							% make the stimuli			for j = 1:numstim				eval(['images.',names{j},'= real(ifft2(fft2(unfilteredimages.',names{j},').*filt));']);				eval(['temp = images.',names{j},'*(cmax/max(max(abs(images.',names{j},'))));']);				vmax(j) = std(temp(:))^2;					end			basevar = min(vmax);			for j = 1:numstim				eval(['images.',names{j},'= images.',names{j},'.*sqrt(basevar/std(images.',names{j},'(:))^2);']);			end					else			images = unfilteredimages;			basevar = unfiltbasevar;			for j = 1:numstim				eval(['images.',names{j},'= images.',names{j},'.*sqrt(basevar/std(images.',names{j},'(:))^2);']);			end		end								% make the selection window 		coords = getcoords(100,numstim,rects,20);		if filtertemps			select = mkselectwin(coords,100/imagesz(1),rects,images,names);			select = select.*sqrt(basevar/std(select(:))^2);		else			select = mkselectwin(coords,100/imagesz(1),rects,unfilteredimages,names);			select = select.*sqrt(unfiltbasevar/std(select(:))^2);		end		[select,selectclut] = makeimage(select,cal);		% keypress to continue		screen(screens(1),'FillRect',0);		flushevents('mouseUp','mouseDown');		sound(introsnd);		screen(screens(1),'SetClut',selectclut,0);		screen(screens(1),'PutImage',select);		[newx,newy] = centertext(screens(1),rects(1,:),'Click Mouse To Start');		[clicks,x,y] = getclicks;		screen(screens(1),'FillRect',0);				% to store the random number seeds and make the trial source		seeds = {};		trialsrc = mkconstim(stimlevels(:,i),inf,i);				% main loop		for thistrial = 1:maxtrials*numstimlevels					trial = trial+1;				if session == 1				% get the next stimulus level				[trialsrc,conlevel(trial),id(trial)] = gettrial(trialsrc);			end						% make the image			if session == 1				seeds{trial} = randn('state');			else				randn('state',seeds{trial});			end					% if noise is zero, just make the image			if nzvar ~= 0							nz=cliprandn(nzsz,2);						nz=nz*sqrt(.2022/std(nz(:))^2);				eval(['currimage = images.',names{sequence(trial)},'.*sqrt(conlevel(trial)/basevar) + nz;']);			else				eval(['currimage = images.',names{sequence(trial)},'.*sqrt(conlevel(trial)/basevar);']);			end			[currimage,CLUT]=makeimage(currimage,cal);			% fixation			screen(screens(1),'SetClut',selectclut,0);			screen(screens(1),'PutImage',basefixation + randfixation*coinflip(1,.5));					% wait for mouse click			[clicks,x,y] = getclicks(screens(1));					% if the user double clicked, show the # of remaining trials			% wait for another click to proceed with next trial			if clicks > 1				screen(screens(1),'SetClut',selectclut,0);				screen(screens(1),'FillRect',0);				[newx,newy] = centertext(screens(1),rects(1,:),num2str(totaltrials-counter),rects(1,4)/2,210);				[clicks,x,y] = getclicks(screens(1));				screen(screens(1),'FillRect',0);				screen(screens(1),'PutImage',basefixation + randfixation*coinflip(1,.5));								waitsecs(1);			end					% present the image			screen(screens(1),'SetClut',CLUT,0);			screen(screens(1),'PutImage',currimage);			waitsecs(duration);			screen(screens(1),'FillRect',0);						% present the selection window			screen(screens(1),'SetClut',selectclut,0);			screen(screens(1),'PutImage',select);					% get the response			responses(trial,session) = selectimage(coords,[0,0,10,10],screens(1));			screen(screens(1),'FillRect',0);			% quit?			if responses(trial,session) < 1				% close the screen.				sound(introsnd);				screen CloseAll;				% close the file				fclose(fwid);									return;			end					% accuracy			correct(trial,session)=sequence(trial)==responses(trial,session);			if correct(trial,session)				sound(corrsnd);			else				sound(wrongsnd);			end					% save the data			data=[trial,sequence(trial),responses(trial,session),correct(trial,session),conlevel(trial),freq(id(trial))/2,(seeds{trial})'];			fprintf(fwid,'%g\t',data); 			fprintf(fwid,'\n');			if session == 1				% update trial source				trialsrc = telltrial(trialsrc,conlevel(trial),correct(trial,session));			end								% increment			counter = counter+1;					end					end	% close the screen.	sound(introsnd);	screen CloseAll;		% close the file	fclose(fwid);		% turn on filesharing	%if fileshareoff	%	status=fs('On');	%end	else		printstr('Not enough input arguments.')endreturn