function dualtask(name,mainscrs,maxtrials,noiselevels,approxthresh,numstimlevels,responseorder,responsesuppress,displaysuppress,noisepixelsize,stimnoise,constfixation,snd1freq,snd2freq,blocknz,numshift,logrange,numsessions)% function dualtask(name,mainscrs,maxtrials,noiselevels,approxthresh,numstimlevels,responseorder,responsesuppress,displaysuppress,noisepixelsize,stimnoise,constfixation,snd1freq,snd2freq,,blocknz,numshift,logrange,numsessions)%% finds thresholds in the dual task noise masking experiment% uses method of constant stimuli% default screen is 1.%% Sept 1 1999  JMG  U of Toronto Vision Labif nargin > 1	% change directories to the main folder	jg home;			% defaults	defarg('mainscrs',2);	defarg('maxtrials',35);	defarg('noiselevels',[0	0.0004	0.0016	0.0064	0.0144	0.0256	0.0625	0.1089]);	defarg('approxthresh',logspace(log10(1e-5),log10(1e-2),length(noiselevels)));	defarg('numstimlevels',6);	defarg('responseorder','gct');	defarg('responsesuppress','');	defarg('displaysuppress','');	defarg('noisepixelsize',1);	defarg('stimnoise',0);	defarg('constfixation',0);	defarg('snd1freq',1990);	defarg('snd2freq',2000);		defarg('blocknz',1);	defarg('numshift',0);	defarg('logrange',2);	defarg('numsessions',1);			% error checking	numnoiselevels = length(noiselevels);	if length(approxthresh) < numnoiselevels		printstr('number of noise levels and threshold estimates do not match.');		break;	end	% constants & parameters	pauseduration = .5;	key1 = abs('1'); % left,low,s	key2 = abs('2'); % right, high, 5	fileshareoff = 1;	calfile = 'c3po12_29_99.DDF';	darktime = 120;	msgcolor = 210;	framert = 67;	frames = 2;	%fixationframes = 6+round(framert); 	fixationframes = 6+round(framert/2);	vd = 100;	screensz = [23 17];	res = [640  480];	hdisdeg = 2.3;	vdisdeg = 1.54;	hdiscm = vd*tan(deg2rad(hdisdeg));	vdiscm = vd*tan(deg2rad(vdisdeg));	hdis = round(cm2pix(hdiscm,screensz,res));	vdis = round(cm2pix(vdiscm,screensz,res));	cpd = 2.3;	gaborszdeg = 1.54;	gaborszcm = vd*tan(deg2rad(gaborszdeg));		gaborsz = round(cm2pix(gaborszcm,screensz,res));	freq = cpd2cpi(cpd,gaborszcm,vd);	imagerect = setrect([res(1)/2+hdis],[vdis+res(2)/2],[res(1)/2+hdis+gaborsz],[vdis+res(2)/2+gaborsz]);	phz = 0;	deg1 = 12;	deg2 = -12;	sddeg = 0.385;	sdpix =  round(cm2pix(vd*tan(deg2rad(sddeg)),screensz,res));	cpw = 4*sdpix*freq/gaborsz;	Hz = 22254.545454; % see sndplay.m for details	amp1 = .8;	amp2 = .8;	charsizedeg = 0.288;	charsizepix = round(cm2pix(vd*tan(deg2rad(charsizedeg)),screensz,res));	charsizepoints = charsizepix*1.25; % 8 pixels is about 10 points in height (10/8 = 1.25)	smallfontsize = charsizepoints;	bigfontsize = 26;		% fixation point	basefixation = ones(4)*70;	if constfixation		randfixation = zeros(4);		else		randfixation = ones(4)*120;	end		% make sounds	introsnd=makesnd(140,.2,.5);	corrsnd=makesnd(400,.09,.5);	wrongsnd=makesnd(200,.09,.5);		% open the screens	defclut=[0:255]'*[1 1 1];	defclut(1,:)=[160 160 160];	defclut(2,:)=[msgcolor msgcolor msgcolor];	[screens,rects] = openscreens(mainscrs,defclut);	screen(screens(1),'WindowToFront')	screen(screens(1),'Preference','SetClutWaitVBL',1);	screen(screens(1),'Preference','WaitForVBLInterrupt',1);	[oldfont,oldsz,oldstyle] = settext(screens(1),'Times',bigfontsize,1);	[newx,newy] = centertext(screens(1),rects(1,:),'Pause For Adaptation',rects(1,end)-50,1);	tic;	% hide the cursor;	hidecursor;	% get the calibration data	[cal1] = getddf(calfile);	% open the off-screen windows	numwindows = 6;	offscrptrs=zeros(numwindows,1);	for i=1:numwindows		offscrPtrs(i)=SCREEN(mainscrs,'OpenOffscreenWindow',0);	end	% tones	s1 = makesnd(snd1freq,(frames*3)/framert,amp1,Hz);	s2 = makesnd(snd2freq,(frames*3)/framert,amp2,Hz);	if isempty(findstr('t',displaysuppress))		snd1 = [s1,s2].*dogauss(length(s1)*2,length(s1)/2,0);		snd2 = [s2,s1].*dogauss(length(s1)*2,length(s1)/2,0);	else		snd1 = zeros(size([s1,s2]));		snd2 = snd1;		responsesuppress = union('t',responsesuppress);	end	% create the gabors	images.g1 = dogabor(freq,cpw,gaborsz,deg1,phz);	images.g2 = dogabor(freq,cpw,gaborsz,deg2,phz);	names = fieldnames(images);	numstim = length(names);	eval(['imagesz = size(images.',names{1},');']);	nzsz = imagesz;		% the variance of images should be the same	eval(['basevar = std(images.',names{1},'(:))^2;']);	images.g2 = images.g2*(sqrt(basevar/stdm(images.g2)^2));	% make file names	found = 0;	loc = 1;	while ~found		if numsessions > 1			filename = [name,num2str(loc),'dualtaskcon.dat'];		else			filename = [name,num2str(loc),'dualtask.dat'];		end		if ~(exist(filename)==2)			found = 1;		else			loc = loc+1;		end	end		% the stimulus levels to test	for i=1:numnoiselevels		shiftfactor = numshift*(log10(approxthresh(i)*10^(logrange/2))-log10(approxthresh(i)/10^(logrange/2)))/(numstimlevels-1);		stimlevels(:,i) = logspace(log10(approxthresh(i)./10^(logrange/2))+shiftfactor,log10(approxthresh(i).*10^(logrange/2))+shiftfactor,numstimlevels)';	end		% open the data file and write the header	if exist(filename) ~= 2		fwid = fopen(filename,'a+');					savecomment(fwid,['Data File Name: ',filename]);		savecomment(fwid,'eqnoise experiment');		savecomment(fwid,['calibration file: ',calfile]);		savecommand(fwid,['responseorder = ',quotestring(responseorder),';']);		savecommand(fwid,['responsesuppress = ',quotestring(responsesuppress),';']);		savecommand(fwid,['displaysuppress = ',quotestring(displaysuppress),';']);		savecommand(fwid,['snd1freq = ',num2str(snd1freq),'; snd2freq = ',num2str(snd2freq),';']);		savecommand(fwid,['orientations = [',num2str([deg1 deg2]),'];']);		savecommand(fwid,['sddeg = ',num2str(sddeg),'; sdpix = ',num2str(sdpix),';']);		savecommand(fwid,['cpi = ',num2str(freq),'; cpw = ',num2str(cpw),'; phase = ',num2str(phz),';']);		savecommand(fwid,['gaborszpix = ',num2str(gaborsz),'; gaborszcm = ',num2str(gaborszcm),'; gaborszdeg = ',num2str(gaborszdeg),';']);		savecommand(fwid,['charszpix = ',num2str(charsizepix),'; charszpoints = ',num2str(charsizepoints),'; charszdeg = ',num2str(charsizedeg),';']);		savecommand(fwid,['viewingdistance = ',num2str(vd),'; resolution = [',num2str(rects(1,3)),',',num2str(rects(4)),']; gam = ',num2str(1/numstim),';']);		savecommand(fwid,['darktime = ',num2str(darktime),';trials = ',num2str(maxtrials),';']);		savecommand(fwid,['trial = 1; sequenceg = 2; responseg = 3;',...						  'correctg = 4; stimlevel = 5; condition = 6;',...						  'randnstate1 = 7; randnstate2 = 8; rtg = 9;',...						  'sequencec = 10; responsec = 11; correctc = 12;',...						  'rtc = 13; sequencet = 14; responset = 15;',...						  'correctt = 16; rtt = 17;']);		savedatetime(fwid);	else		fwid = fopen(filename,'a+');					savedatetime(fwid);	end	% turn off filesharing	if fileshareoff		status=fs('Off');	end		% continue dark adptation	hidecursor;	done=toc;	togo=darktime-done;	passed=0;	start=GetSecs;	hit='9';	while getsecs-start < togo & abs(hit)~=48  	% zero key skips adaptation		if CharAvail			hit=getchar;		end	end	% initialize sndplay.m	sndplay(0);		% keypress to continue	screen(screens(1),'FillRect',0);	sound(introsnd);	[newx,newy] = centertext(screens(1),rects(1,:),'Press Any Key To Start',rects(1,end)/2,msgcolor);	flushevents('keyDown');	dummy = getchar;	screen(screens(1),'FillRect',0);	% initialize	sequenceg = rands([1:2],[1,maxtrials*numstimlevels*numnoiselevels]);	sequencet = rands([1:2],[1,maxtrials*numstimlevels*numnoiselevels]);	sequencec = rands([[abs('0'):abs('4')],[abs('6'):abs('9')],[abs('a'):abs('r')],[abs('t'):abs('z')]],[5,maxtrials*numstimlevels*numnoiselevels]);	sequencetemp = rands([abs('5'),abs('s')],[1,maxtrials*numstimlevels*numnoiselevels]);	sequencec(3,:) = sequencetemp;		% for the responses	responsesg = zeros([length(sequenceg),numsessions]);	responsesc = zeros([length(sequenceg),numsessions]);	responsest = zeros([length(sequenceg),numsessions]);	correctg = responsesg;	correctc = responsesg;	correctt = responsesg;		totaltrials = maxtrials*numstimlevels*numnoiselevels*numsessions;	pausetrials = round(totaltrials/4);	counter = 1;		% trial source information	conlevel = zeros(size(sequenceg));	id = zeros(size(sequenceg));		% if noise levels are to be blocked	if blocknz 		nzorder = randperm(numnoiselevels);	end	% main loop	for session = 1:numsessions				% to store the random number seeds and make the trial source		if session == 1 & ~blocknz			seeds = {};			trialstring = '';			for i = 1:numnoiselevels				eval(['trialsrc',num2str(i),' = mkconstim(stimlevels(:,',num2str(i),'),inf,',num2str(i),');']);				trialstring = [trialstring,'trialsrc',num2str(i),','];			end			eval(['trialsrc = mktslist(',trialstring(1:end-1),');']);		else			if session > 1 				savecomment(fwid,['session #',num2str(session)]);				savedatetime(fwid);			end		end							% main loop		levelcounter = 0;		for trial = 1:totaltrials/numsessions  					% if noise levels are to be blocked			if blocknz & session == 1 & rem(trial,maxtrials*numstimlevels) == 1				levelcounter = levelcounter+1;				eval(['trialsrc = mkconstim(stimlevels(:,',num2str(nzorder(levelcounter)),'),inf,',num2str(levelcounter),');']);			elseif rem(trial,maxtrials*numstimlevels) == 1				levelcounter = levelcounter+1;			end					% get the current noise level			if blocknz 				currnoiselevel = noiselevels(nzorder(levelcounter));					else					currnoiselevel = noiselevels(id(trial));			end					if session == 1				% get the next stimulus level				[trialsrc,conlevel(trial),id(trial)] = gettrial(trialsrc);			end					% get noise seed						if session == 1				seeds{trial} = randn('state');			else				randn('state',seeds{trial});			end					% for character sequencing			if sequencec(3,trial) == '5'				tempsequencec = 1;			else				tempsequencec = 2;			end			% holds rt's			rtg = -1;			rtc = -1;			rtt = -1;							% do off screen windows			cluts = [];			for i = 1:numwindows-1								% clear the current window				screen(offscrPtrs(i),'FillRect',0);								if isempty(findstr('g',displaysuppress))					% the noise & gabor										if i ~= numwindows/2 | (i == numwindows/2 & stimnoise == 1)						if noisepixelsize == 1								currimage=cliprandn(nzsz,2);						else							currimage=cliprandn(nzsz/noisepixelsize,2);							currimage=expand(currimage,noisepixelsize);						end											currimage=currimage*sqrt(currnoiselevel/std(currimage(:))^2);												% add stimlus if noise is overlapping (i.e., stimnoise == 1)						if (i == numwindows/2 & stimnoise == 1)							eval(['currimage = currimage + images.',names{sequenceg(trial)},'.*sqrt(conlevel(trial)/basevar);']);						end											else						eval(['currimage = images.',names{sequenceg(trial)},'.*sqrt(conlevel(trial)/basevar);']);					end					[currimage,tempclut]=makeimage(currimage,cal1,msgcolor);					cluts = [cluts,tempclut];					screen(offscrPtrs(i),'PutImage',currimage,imagerect);				else					responsesuppress = union('g',responsesuppress);					tempclut = defclut;					cluts = [cluts,tempclut];				end					% the character				if isempty(findstr('c',displaysuppress))					[newx,newy,oldtextsz] = centertext(offscrPtrs(i),rects,char(sequencec(i,trial)),rects(4)/2,1,smallfontsize);							else					responsesuppress = union('c',responsesuppress);				end							end					% the sound			eval(['snd = snd',num2str(sequencet(trial)),';']);			% dummy clut for last window (blank)			cluts = [cluts,tempclut];			% loop for showing the movie			loop = 	['sndplay(snd);',...					'for i = 1:length(offscrPtrs),',... 						'screen(screens(1),''SetClut'',cluts(:,(i-1)*3+1:i*3),0);',...						'screen(''CopyWindow'',offscrPtrs(i),screens(1));',...						'screen(screens(1),''WaitVBL'',frames-1);',...					'end;'];							% see if user wants to pause			key = pollpause(screens(1),'0',num2str(totaltrials-counter),500,.25,1,1);			% fixation			screen(screens(1),'SetClut',defclut,0);			screen(screens(1),'PutImage',basefixation + randfixation*coinflip(1,.5));							WaitTicks(fixationframes);			screen(screens(1),'FillRect',0);							% show the movie			eval(loop);			% start timer						tic;						% get the response			for i = 1:3								if ~ismember(responseorder(i),responsesuppress)										% show a selection window based on response order					if responseorder(i) == 'g'						[newx,newy] = centertext(screens(1),rects(1,:),'GRATING',100,1,40);						[newx,newy] = centertext(screens(1),rects(1,:),'left             right',rects(1,end)/2,1,45);					elseif responseorder(i) == 'c'						[newx,newy] = centertext(screens(1),rects(1,:),'CHARACTER',100,1,40);						[newx,newy] = centertext(screens(1),rects(1,:),'5             s',rects(1,end)/2,1,45);					elseif responseorder(i) == 't'						[newx,newy] = centertext(screens(1),rects(1,:),'TONE',100,1,40);						[newx,newy] = centertext(screens(1),rects(1,:),'up             down',rects(1,end)/2,1,45);					end										% get response					flushevents('keyDown');					resp = '9';					while abs(resp)~= key1 & abs(resp)~=key2 & ~isquitkey(resp)						resp = getchar;					end					rt = toc;					eval(['rt',responseorder(i),' = rt;']);					if abs(resp)==key1						eval(['responses',responseorder(i),'(trial,session) = 1;']);					elseif abs(resp)==key2						eval(['responses',responseorder(i),'(trial,session) = 2;']);					elseif isquitkey(resp)						sound(introsnd);						closeall;						return;					end					flushevents('keyDown');													% accuracy					if responseorder(i) == 'c'						correctc(trial,session)=tempsequencec==responsesc(trial,session);					else						eval(['correct',responseorder(i),'(trial,session)=sequence',responseorder(i),'(trial)==responses',responseorder(i),'(trial,session);']);					end					eval(['feedback = correct',responseorder(i),'(trial,session);']);					if feedback						sound(corrsnd);					else						sound(wrongsnd);					end									% clear screen					screen(screens(1),'FillRect',0);						end						end							% save the data			data = [trial,sequenceg(trial),responsesg(trial,session),correctg(trial,session),conlevel(trial),currnoiselevel,(seeds{trial})',rtg];			data = [data,tempsequencec,responsesc(trial,session),correctc(trial,session),rtc,sequencet(trial),responsest(trial,session),correctt(trial,session),rtt];			fprintf(fwid,'%g\t',data); 			fprintf(fwid,'\n');			if session == 1				% update trial source				trialsrc = telltrial(trialsrc,conlevel(trial),correctg(trial,session));			end						% pause for a break			if rem(trial,maxtrials*numstimlevels) == 0 & trial>1 & trial*session<totaltrials				[newx,newy] = centertext(screens(1),rects(1,:),['Take a break. ',num2str(totaltrials-counter),' trials remaining.'],round(rects(1,4)*.4),1);				[newx,newy] = centertext(screens(1),rects(1,:),['Press Any Key To Continue.'],round(rects(1,4)*.6),1);				dummy = getchar;				screen(screens(1),'FillRect',0);			end					% increment			counter = counter+1;					end					end	% close the screen.	sound(introsnd);	screen CloseAll;		% close the file	fclose(fwid);		% turn on filesharing	%if fileshareoff	%	status=fs('On');	%end	else		printstr('Not enough input arguments.')endreturn