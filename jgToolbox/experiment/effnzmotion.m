function effnzmotion(name,mainscrs,maxtrials,noiselevels,approxthresh,numsessions,numstimlevels,numshift,logrange,endlabel,feedback,stimtype,stimframes,isiframes)% function effnzmotion(name,mainscrs,maxtrials,noiselevels,approxthresh,numsessions,numstimlevels,numshift,logrange,endlabel,feedback,stimtype)%% finds thresholds in the noise masking motion experiment% uses method of constant stimuli% 'name' is the name the subject, in intials%% March 1 2000  JMG  U of Toronto Vision Labif nargin,	% change directories to the main folder	cf;	jg local;		% defaults	defarg('mainscrs',1);	defarg('maxtrials',2); % 50 	defarg('noiselevels',logspace(log10(1e-4),log10(.01),5));	defarg('numsessions',2);	defarg('numstimlevels',5);	defarg('numshift',zeros(length(noiselevels)));	defarg('logrange',2);	defarg('approxthresh',logspace(log10(5e-4),log10(.005),5));	defarg('endlabel','');	defarg('feedback',1);	defarg('stimframes',1);	defarg('isiframes',1);	defarg('dotwidthDeg',0.05);	defarg('stimtype','position');		% covert to numbers if necessary	checkstr(mainscrs,maxtrials);		% check for the passed screen; if not there, use the highest one	screensAvail = screen('Screens');	if isempty(find(mainscrs==screensAvail))		mainscrs = screensAvail(end);	end		% error checking	numnoiselevels = length(noiselevels);	if length(approxthresh) < numnoiselevels | length(numshift) ~= numnoiselevels		printstr('number of noise levels, threshold estimates, and shift factors do not match.');		return;	end		% constants	key1 = abs('1');	key2 = abs('2');	gam = 0.5;	pc = .75;	fileshareoff = 1;	darktime = 120;	basefixation = ones(4)*70;	randfixation = ones(4)*120;	msgcolor = 190;	framert = round(framerate(mainscrs,30));	screensz = [23 17];		% make stimuli	endframes = 1;	dotwidthP = 2;	dotlengthP = dotwidthP*3;	dotsepP = dotwidthP;	padP = dotwidthP;	dot = ones(dotlengthP,dotwidthP).*-1;	dotleft = [dot,dot.*0,dot.*0];	dotleft = pad(dotleft,[padP,padP,padP,padP],0);	dotright = fliplr(dotleft);	image1 = zeros(size(dotleft,1),size(dotleft,2),stimframes+isiframes);	image2 = image1;	endmovie = zeros(size(dotleft,1),size(dotleft,2),endframes);		% motion condition	if strcmp(stimtype,'motion'),			for i = 1:stimframes,			image1(:,:,i) = dotleft;			image2(:,:,i) = dotright;		end			for i = stimframes+isiframes+1:stimframes+isiframes+stimframes,			image1(:,:,i) = dotright;			image2(:,:,i) = dotright;		end		% position condition	else		for i = 1:stimframes,			image1(:,:,i) = dotleft;		end			for i = stimframes+isiframes+1:stimframes+isiframes+stimframes,			image2(:,:,i) = dotright;		end			imagename1 = 'left';		imagename2 = 'right';						end	image1 = cat(3,endmovie,cat(3,image1,endmovie));		image2 = cat(3,endmovie,cat(3,image2,endmovie));		nzsz = size(image1);	basevar = std(image1(:)).^2;				% make sounds	introsnd=makesnd(150,.2,.95);	corrsnd=makesnd(600,.09,.65);	wrongsnd=makesnd(200,.09,.8);	% get the calibration data	% it should be stored in the local folder	% if it is not, ask user for location	% calibration file	d = dir('*.ddf');	ddfnames = {d.name};	if length(ddfnames) ~= 1		[calfile,calfolder] = uigetfile('*.ddf','Where is the calibration file?');		if ~calfile,			return;		end	else		calfolder = pwd;		calfile = ddfnames{1};	end	[cal1] = getddf(calfile,calfolder);		% open the screens	tempCLUT=ones(256,3)*160;	tempCLUT(2,:)=[msgcolor msgcolor msgcolor];	[screens,rects] = openscreens(mainscrs,tempCLUT);	% viewing distance	res = rects(1,3:4);	szpixcm = pix2cm(1,screensz,res);	vd = (szpixcm*dotwidthP)/tan(deg2rad(dotwidthDeg));	screen(screens(1),'WindowToFront')	screen(screens(1),'Preference','SetClutWaitVBL',1);	screen(screens(1),'Preference','WaitForVBLInterrupt',1);		[oldfont,oldsz,oldstyle] = settext(screens(1),'Times',26,1);	[newx,newy] = centertext(screens(1),rects(1,:),'Pause For Adaptation',rects(1,end)-50,1);	[newx,newy] = centertext(screens(1),rects(1,:),['set viewing distance to ',num2str(round(vd)),' cm.'],50,1);	tic;		% hide the cursor;	hidecursor;		% seed the random number generator	clockseed = sum(100*clock);	randn('state',clockseed);	% make file names	found = 0;	loc = 1;		% stimulus type	while ~found		if numsessions > 1			filename = [name,num2str(loc),'ENZCON',stimtype,endlabel,'.dat'];		else			filename = [name,num2str(loc),'ENZ',stimtype,endlabel,'.dat'];		end		if ~(exist(filename)==2)			found = 1;		else			loc = loc+1;		end	end		% the stimulus levels to test	for i=1:numnoiselevels		shiftfactor = numshift(i)*(log10(approxthresh(i)*10^(logrange/2))-log10(approxthresh(i)/10^(logrange/2)))/(numstimlevels-1);		stimlevels(:,i) = logspace(log10(approxthresh(i)./10^(logrange/2))+shiftfactor,log10(approxthresh(i).*10^(logrange/2))+shiftfactor,numstimlevels)';	end	% open the off-screen windows	numwindows = size(image1,3)+1;	offscrptrs=zeros(numwindows,1);	for i=1:numwindows		offscrPtrs(i)=SCREEN(mainscrs,'OpenOffscreenWindow',0);	end	% dummy clut	selectclut = [0:255]'*[1 1 1 ];	selectclut(1,:) = [160 160 160];		% open the data file and write the header	if exist(filename) ~= 2				% names		fwid = fopen(filename,'a+');					savecomment(fwid,['Data File Name: ',filename]);		savecomment(fwid,['eqnoise ',stimtype,' experiment']);		savecommand(fwid,vars2str(calfile));		savecommand(fwid,vars2str(calfolder));		% noise levels		savecommand(fwid,vars2str(numnoiselevels));		savecommand(fwid,vars2str(numstimlevels));		savecommand(fwid,vars2str(numnoiselevels));		savecommand(fwid,vars2str(noiselevels));				% stimulus parameters		savecommand(fwid,vars2str(clockseed));		savecommand(fwid,vars2str(stimtype));		savecommand(fwid,vars2str(calfile));		savecommand(fwid,vars2str(screensz));		savecommand(fwid,vars2str(res));		savecommand(fwid,vars2str(framert));		savecommand(fwid,vars2str(stimframes));		savecommand(fwid,vars2str(vd));		savecommand(fwid,vars2str(approxthresh));		savecommand(fwid,vars2str(numshift));		savecommand(fwid,vars2str(logrange));		savecommand(fwid,vars2str(isiframes));		savecommand(fwid,vars2str(dotwidthDeg));		savecommand(fwid,vars2str(key1));		savecommand(fwid,vars2str(key2));		savecommand(fwid,vars2str(endframes));		savecommand(fwid,vars2str(dotlengthP));		savecommand(fwid,vars2str(dotsepP));		savecommand(fwid,vars2str(padP));		savecommand(fwid,vars2str(imagename1));		savecommand(fwid,vars2str(imagename2));		% procedural parameters		savecommand(fwid,vars2str(feedback));		savecommand(fwid,vars2str(darktime));		savecommand(fwid,vars2str(maxtrials));		savecommand(fwid,vars2str(mainscrs));		savecommand(fwid,vars2str(gam));		savecommand(fwid,vars2str(pc));			% tags for data columns		savecommand(fwid,'trial = 1; sequence = 2; response = 3; correct = 4; stimlevel = 5; condition = 6; randnstate1 = 7; randnstate2 = 8;');		% date and time		savedatetime(fwid);			else		fwid = fopen(filename,'a+');					savedatetime(fwid);	end	% turn off filesharing	if fileshareoff		status=fs('Off');	end		% continue dark adptation	hidecursor;	done=toc;	togo=darktime-done;	passed=0;	start=GetSecs;	hit='9';	while getsecs-start < togo & abs(hit)~=48  	% zero key skips adaptation		if CharAvail			hit=getchar;		end	end		% keypress to continue	screen(screens(1),'FillRect',0);	sound(introsnd);	screen(screens(1),'SetClut',selectclut,0);	[newx,newy] = centertext(screens(1),rects(1,:),'press any key to continue',rects(1,end)/2,msgcolor);	flushevents('keyDown');	dummy = getkey;	screen(screens(1),'FillRect',0);	% initialize	sequence = rands([1:2],[1,maxtrials*numstimlevels*numnoiselevels]);	conlevel = zeros(size(sequence));	id = zeros(size(sequence));		% for the responses	responses = ones([length(sequence),numsessions]);	correct = responses;	totaltrials = maxtrials*numstimlevels*numnoiselevels*numsessions;	pausetrials = round(totaltrials/4);	counter = 1;			% outer loop: sessions	for session = 1:numsessions				% to store the random number seeds and make the trial source		if session == 1			seeds = {};			trialstring = '';			for i = 1:numnoiselevels				eval(['trialsrc',num2str(i),' = mkconstim(stimlevels(:,',num2str(i),'),inf,',num2str(i),');']);				trialstring = [trialstring,'trialsrc',num2str(i),','];			end			eval(['trialsrc = mktslist(',trialstring(1:end-1),');']);		else			savecomment(fwid,['session #',num2str(session)]);			savedatetime(fwid);		end				% main loop: trials within sessions		for trial = 1:totaltrials/numsessions  					if session == 1				% get the next stimulus level				[trialsrc,conlevel(trial),id(trial)] = gettrial(trialsrc);			end						% make the image			if session == 1				seeds{trial} = randn('state');			else				randn('state',seeds{trial});			end								% fixation			screen(screens(1),'SetClut',selectclut,0);			% screen(screens(1),'PutImage',basefixation);				% make the image			randnstate = randn('state');			cluts = [];			eval(['currimage=image',num2str(sequence(trial)),'.*sqrt(conlevel(trial)/basevar);']);			nz = cliprandn(size(currimage));			nz = nz.*(sqrt(noiselevels(id(trial))/(std(nz(:)).^2)));			currimage = currimage+nz;			for i = 1:numwindows-1				% clear the current window				screen(offscrPtrs(i),'FillRect',0);				[tempimage,tempclut]=makeimage(currimage(:,:,i),cal1);				cluts = [cluts,tempclut];				screen(offscrPtrs(i),'PutImage',tempimage);						end							% dummy clut for last window (blank)			cluts = [cluts,tempclut];				% see if user wants to pause			dopause = pollpause(screens(1),'0',num2str(maxtrials-trial),500,.1);				% loop for showing the movie			loop = 	['for i = 1:length(offscrPtrs),',... 						'screen(screens(1),''SetClut'',cluts(:,(i-1)*3+1:i*3),0);',...						'screen(''CopyWindow'',offscrPtrs(i),screens(1));',...						'screen(screens(1),''WaitVBL'',1);',...					'end;'];								% show the movie			screen(screens(1),'FillRect',0);			eval(loop);			screen(screens(1),'WaitVBL',1);			screen(screens(1),'FillRect',0);						% get the response			flushevents('keyDown');			resp = '9';			while abs(resp)~= key1 & abs(resp)~=key2 & ~isquitkey(resp)				resp = getchar;			end			if abs(resp)==key2				responses(trial) = 2;			elseif isquitkey(resp)				break;			end								% accuracy			correct(trial,session)=sequence(trial)==responses(trial,session);			if feedback,				if correct(trial,session)					sound(corrsnd);				else					sound(wrongsnd);				end			end						% save the data			data=[trial,sequence(trial),responses(trial,session),correct(trial,session),conlevel(trial),noiselevels(id(trial))];			fprintf(fwid,'%g\t',data); 			fprintf(fwid,'%.0f\t',(seeds{trial})');			fprintf(fwid,'\n'); 						% pause for a break			if rem(trial,pausetrials) == 0 & trial*session<totaltrials				screen(screens(1),'SetClut',selectclut,0);				[newx,newy] = centertext(screens(1),rects(1,:),['take a break. ',num2str(totaltrials-counter),' trials remaining.'],round(rects(1,4)*.4),msgcolor);				[newx,newy] = centertext(screens(1),rects(1,:),['press any key to continue.'],round(rects(1,4)*.6),msgcolor);				dummy = getchar;								screen(screens(1),'FillRect',0);			end					% increment counter			counter = counter+1;					end					end		% close the screen.	sound(introsnd);	screen CloseAll;		% close the file	fclose(fwid);	else	% error feedback	printstr('Not enough input arguments.')endreturn