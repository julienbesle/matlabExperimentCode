function effnz(name,mainscrs,maxtrials,stimfile,numstim,noiselevels,approxthresh,numsessions,numstimlevels,numshift,logrange,showstim,rotation,polarity,endlabel,usekeys,feedback,stimsize)% function effnz(name,mainscrs,maxtrials,stimfile,numstim,noiselevels,approxthresh,numsessions,numstimlevels,numshift,logrange,showstim,rotation,polarity,endlabel)%% finds thresholds in the noise masking experiment% uses method of constant stimuli% 'name' is the name the subject, in intials%% March 1 2000  JMG  U of Toronto Vision Labif nargin,	% change directories to the main folder	cf;	jg local;		% defaults	defarg('mainscrs',1);	defarg('maxtrials',40);	defarg('numstim',10);	defarg('stimfile','NoiseStruct1.mat');	defarg('noiselevels',0.0625);  % lo: 5e-4   hi:0.0625	defarg('numsessions',2);	defarg('numstimlevels',5);	defarg('rotation',0);	defarg('polarity','pos');	defarg('numshift',zeros(length(noiselevels)));	defarg('logrange',2);	defarg('approxthresh',2.5e-4);	defarg('showstim',[1:numstim]);		defarg('endlabel','');	defarg('usekeys',1);	defarg('feedback',1);	% covert to numbers if necessary	checkstr(mainscrs,maxtrials,numstim);		% check for the passed screen; if not there, use the highest one	screensAvail = screen('Screens');	if isempty(find(mainscrs==screensAvail))		mainscrs = screensAvail(end);	end		% error checking	numnoiselevels = length(noiselevels);	if length(approxthresh) < numnoiselevels | length(numshift) ~= numnoiselevels		printstr('number of noise levels, threshold estimates, and shift factors do not match.');		return;	end		% constants	pauseduration = 0.5;	fileshareoff = 1;	darktime = 120;	basefixation = ones(4)*70;	randfixation = ones(4)*120;	msgcolor = 190;	framert = round(framerate(mainscrs,30));	stimframes = round(framert/2);	vd = 100;	screensz = [23 17];	gam = 1/numstim;			% make sounds	introsnd=makesnd(150,.2,.95);	corrsnd=makesnd(600,.09,.65);	wrongsnd=makesnd(200,.09,.8);	% get the calibration data	% it should be stored in the local folder	% if it is not, ask user for location		% open the screens	tempCLUT=ones(256,3)*160;	tempCLUT(2,:)=[msgcolor msgcolor msgcolor];	[screens,rects] = openscreens(mainscrs,tempCLUT);	screen(screens(1),'WindowToFront')	screen(screens(1),'Preference','SetClutWaitVBL',1);	screen(screens(1),'Preference','WaitForVBLInterrupt',1);		[oldfont,oldsz,oldstyle] = settext(screens(1),'Times',26,1);	[newx,newy] = centertext(screens(1),rects(1,:),'Pause For Adaptation',rects(1,end)-50,1);	res = rects(1,3:4);	tic;	% hide the cursor;	hidecursor;		% seed the random number generator	clockseed = sum(100*clock);	randn('state',clockseed);		% load the stimulus file. stimuli are stored in the structure 'images'.	load(stimfile);	names = fieldnames(images);	numimages = length(names);	% error checking	if length(showstim) > numstim | sum(showstim>numimages)		printstr('number of stimuli and requested stimuli do not match.');		return;	end				% reverse polarity	if strcmp(polarity,'neg')		for i = 1:numimages			eval(['images.',names{i},' = images.',names{i},'*-1;']);		end	end	% rotate	if rotation		if rotation == 180			for i = 1:numimages				eval(['images.',names{i},' = rot90(rot90(images.',names{i},'));']);			end		end	end	% adjust size ?	eval(['basesize = max(size(images.',names{i},'));']);	defarg('stimsize',basesize);		if stimsize ~= basesize		for i = 1:numimages,			eval(['images.',names{i},' = imresize(images.',names{i},',stimsize/basesize);']);		end			% recompute average amplitude spectrum		images = avemag(images,.1);	end	% get requested images	if numimages ~= numstim				if numimages < numstim						error('Not enough images.')			return;		else			images = rmfield(images,names(setdiff([1:numimages],showstim)));		end	end	names = fieldnames(images);	eval(['imagesz = size(images.',names{1},');']);	nzsz = imagesz;		% the variance of all images is the same	eval(['basevar = std(images.',names{1},'(:))^2;']);		% duration and stimulus location	duration = .5;	imagerect = [];		% make file names	found = 0;	loc = 1;		% stimulus type	if findstr('noise',lower(stimfile))		stimtype = 'text';	elseif findstr('letter',lower(stimfile))		stimtype = 'let';	elseif findstr('face',lower(stimfile))		stimtype = 'face';	else		stimtype = '';	end			while ~found		if numsessions > 1			filename = [name,num2str(loc),stimtype,'ENZcon',polarity,num2str(rotation),endlabel,'.dat'];		else			filename = [name,num2str(loc),stimtype,'ENZ',polarity,num2str(rotation),endlabel,'.dat'];		end		if ~(exist(filename)==2)			found = 1;		else			loc = loc+1;		end	end		% the stimulus levels to test	for i=1:numnoiselevels		shiftfactor = numshift(i)*(log10(approxthresh(i)*10^(logrange/2))-log10(approxthresh(i)/10^(logrange/2)))/(numstimlevels-1);		stimlevels(:,i) = logspace(log10(approxthresh(i)./10^(logrange/2))+shiftfactor,log10(approxthresh(i).*10^(logrange/2))+shiftfactor,numstimlevels)';	end	% make the selection window	thumbsz = 100; 	coords = getcoords(thumbsz,numstim,rects,20);	if usekeys,		% assign the keys		keys = rmchar(num2str(rem([1:length(names)],10)),' ');	else		keys = '';	end		keysz = 16;		[select,selectclut] = mkselectwinkeys(coords,thumbsz/imagesz(1),rects,images,cal1,mainscrs,keys,msgcolor,keysz);	% open the off-screen windows	numwindows = 3;	offscrptrs=zeros(numwindows,1);	for i=1:numwindows		offscrPtrs(i) = SCREEN(mainscrs,'OpenOffscreenWindow',0);		offscrCluts{i} = zeros(256,3);	end	% place the selection window	screen(offscrPtrs(1),'PutImage',select);	offscrCluts{1} = selectclut;		% open the data file and write the header	if exist(filename) ~= 2				% names		fwid = fopen(filename,'a+');					savecomment(fwid,['Data File Name: ',filename]);		savecomment(fwid,'eqnoise experiment');		savecomment(fwid,['image names: ',strcat(names{1:end})]);		savecommand(fwid,vars2str(calfile));		savecommand(fwid,vars2str(calfolder));		% noise levels		savecommand(fwid,vars2str(numnoiselevels));		savecommand(fwid,vars2str(numstimlevels));		savecommand(fwid,vars2str(numnoiselevels));		savecommand(fwid,vars2str(noiselevels));				% stimulus parameters		savecommand(fwid,vars2str(clockseed));		savecommand(fwid,vars2str(showstim));		savecommand(fwid,vars2str(stimfile));		savecommand(fwid,vars2str(stimtype));		savecommand(fwid,vars2str(calfile));		savecommand(fwid,vars2str(polarity));		savecommand(fwid,vars2str(rotation));		savecommand(fwid,vars2str(imagesz));		savecommand(fwid,vars2str(screensz));		savecommand(fwid,vars2str(res));		savecommand(fwid,vars2str(framert));		savecommand(fwid,vars2str(stimframes));		savecommand(fwid,vars2str(vd));		savecommand(fwid,vars2str(thumbsz));		savecommand(fwid,vars2str(approxthresh));		savecommand(fwid,vars2str(numshift));		savecommand(fwid,vars2str(logrange));		% procedural parameters		savecommand(fwid,vars2str(keysz));		savecommand(fwid,vars2str(usekeys));		savecommand(fwid,vars2str(keys));		savecommand(fwid,vars2str(feedback));		savecommand(fwid,vars2str(darktime));		savecommand(fwid,vars2str(maxtrials));		savecommand(fwid,vars2str(mainscrs));		savecommand(fwid,vars2str(gam));		savecommand(fwid,vars2str(pc));			% tags for data columns		savecommand(fwid,'trial = 1; sequence = 2; response = 3; correct = 4; stimlevel = 5; condition = 6; rt = 7; randnstate1 = 8; randnstate2 = 9;');		% date and time		savedatetime(fwid);			else		fwid = fopen(filename,'a+');					savedatetime(fwid);	end	% turn off filesharing	if fileshareoff		status=fs('Off');	end		% continue dark adptation	hidecursor;	done=toc;	togo=darktime-done;	passed=0;	start=GetSecs;	hit='9';	while getsecs-start < togo & abs(hit)~=48  	% zero key skips adaptation		if CharAvail			hit=getchar;		end	end		% keypress to continue	screen(screens(1),'FillRect',0);	sound(introsnd);	screen(screens(1),'SetClut',selectclut,0);	screen(screens(1),'PutImage',select);	if usekeys,		[newx,newy] = centertext(screens(1),rects(1,:),'press any key to continue',rects(1,end)/2,msgcolor);		flushevents('keyDown');		dummy = getkey;	else		[newx,newy] = centertext(screens(1),rects(1,:),'click the mouse to start',rects(1,end)/2,msgcolor);		flushevents('mouseDown');		[clicks,x,y] = GetClicks(screens(1));	end	screen(screens(1),'FillRect',0);	% initialize	sequence = rands([1:numstim],[1,maxtrials*numstimlevels*numnoiselevels]);	conlevel = zeros(size(sequence));	id = zeros(size(sequence));		% for the responses	responses = zeros([length(sequence),numsessions]);	correct = responses;	totaltrials = maxtrials*numstimlevels*numnoiselevels*numsessions;	pausetrials = round(totaltrials/4);	counter = 1;			% outer loop: sessions	for session = 1:numsessions				% to store the random number seeds and make the trial source		if session == 1			seeds = {};			trialstring = '';			for i = 1:numnoiselevels				eval(['trialsrc',num2str(i),' = mkconstim(stimlevels(:,',num2str(i),'),inf,',num2str(i),');']);				trialstring = [trialstring,'trialsrc',num2str(i),','];			end			eval(['trialsrc = mktslist(',trialstring(1:end-1),');']);		else			savecomment(fwid,['session #',num2str(session)]);			savedatetime(fwid);		end				% main loop: trials within sessions		for trial = 1:totaltrials/numsessions  					if session == 1				% get the next stimulus level				[trialsrc,conlevel(trial),id(trial)] = gettrial(trialsrc);			end						% make the image			if session == 1				seeds{trial} = randn('state');			else				randn('state',seeds{trial});			end						nz=cliprandn(nzsz);					nz=nz*sqrt(noiselevels(id(trial))/std(nz(:))^2);						eval(['currimage = images.',names{sequence(trial)},'.*sqrt(conlevel(trial)/basevar) + nz;']);			[currimage,CLUT]=makeimage(currimage,cal1);			screen(offscrPtrs(2),'PutImage',currimage);			% fixation			screen(screens(1),'SetClut',selectclut,0);			screen(screens(1),'PutImage',basefixation + randfixation*coinflip(1,.5));									% pause?			if usekeys,				pressed = pollpause(screens(1),'0',num2str(maxtrials-trial),2000,.4);								if ~isempty(pressed)					screen(screens(1),'SetClut',selectclut,0);					screen(screens(1),'PutImage',basefixation + randfixation*coinflip(1,.5));						waitsecs(1);						end			else				% wait for mouse click							[clicks,x,y] = getclicks(screens(1));					% if the user double clicked, show the # of remaining trials				% wait for another click to proceed with next trial				if clicks > 1								screen(screens(1),'SetClut',offscrCluts{1},0);					screen('CopyWindow',offscrPtrs(end),screens(1));					[newx,newy] = centertext(screens(1),rects(1,:),num2str(totaltrials-counter),rects(1,4)/2,210);					[clicks,x,y] = getclicks(screens(1));					screen('CopyWindow',offscrPtrs(end),screens(1));					screen(screens(1),'PutImage',basefixation + randfixation*coinflip(1,.5));									waitsecs(1);				end			end					% present the image			screen(screens(1),'SetClut',CLUT,0);			screen('CopyWindow',offscrPtrs(2),screens(1));			screen(screens(1),'WaitVBL',stimframes);						% present the selection window			screen(screens(1),'SetClut',offscrCluts{1},0);			screen('CopyWindow',offscrPtrs(1),screens(1));						% wait for response			if usekeys,				tic;				flushevents('keyDown');				resp = 'a';				while isempty(find(resp==keys)) & ~isquitkey(resp)					resp = getchar;				end				rt = toc;				if isquitkey(resp),					responses(trial,session) = -1;				else					responses(trial,session) = str2num(resp);				end							if responses(trial,session) == 0,					responses(trial,session) = 10;				end						else								tic;				responses(trial,session) = selectimage(coords,[0,0,10,10],screens(1));				rt = toc;			end						% clear screen			screen(screens(1),'WaitVBL',1);			screen('CopyWindow',offscrPtrs(end),screens(1));			% quit?			if responses(trial,session) < 1				% close the screen.				sound(introsnd);				screen CloseAll;				% close the file				fclose(fwid);									return;							end						% accuracy			correct(trial,session)=sequence(trial)==responses(trial,session);			if feedback,				if correct(trial,session)					sound(corrsnd);				else					sound(wrongsnd);				end			end						% save the data			data=[trial,showstim(sequence(trial)),showstim(responses(trial,session)),correct(trial,session),conlevel(trial),noiselevels(id(trial)),rt];			fprintf(fwid,'%g\t',data); 			fprintf(fwid,'%.0f\t',(seeds{trial})');			fprintf(fwid,'\n'); 						% pause for a break			if rem(trial,pausetrials) == 0 & trial*session<totaltrials				[newx,newy] = centertext(screens(1),rects(1,:),['take a break. ',num2str(totaltrials-counter),' trials remaining.'],round(rects(1,4)*.4),msgcolor);				if usekeys,					[newx,newy] = centertext(screens(1),rects(1,:),['press any key to continue.'],round(rects(1,4)*.6),msgcolor);					dummy = getchar;								else					[newx,newy] = centertext(screens(1),rects(1,:),['click the mouse to continue.'],round(rects(1,4)*.6),msgcolor);					[clicks,x,y] = getclicks(screens(1));				end				screen(screens(1),'FillRect',0);			end					% increment counter			counter = counter+1;					end					end		% close the screen.	sound(introsnd);	screen CloseAll;		% close the file	fclose(fwid);	else	% error feedback	printstr('Not enough input arguments.')endreturn