function eqnoisemem(name,numshow,soa,uncertainty,mainscrs,maxtrials,noiselevels,approxthresh,numsessions,numstimlevels,noisetype,rotation)% function eqnoisemem(name,numshow,soa,mainscrs,maxtrials,noiselevels,approxthresh,numsessions,numstimlevels,noisetype,rotation)%% finds thresholds in the noise masking experiment% uses method of constant stimuli% 'name' is the name the subject, in intials%% Sept 18 1998  JMG  U of Toronto Vision Labif nargin > 2	% change directories to the main folder	jg feature;			% defaults	defarg('mainscrs',1);	defarg('maxtrials',35);	defarg('noiserange',[1e-4 .0625]);	defarg('numsessions',1);	defarg('numstimlevels',6);	defarg('noisetype','');	defarg('rotation','');	defarg('approxthresh',2.5e-4);	defarg('uncertainty',0);		logrange = 2;	% stimulus and noise levels	if ~exist('noiselevels','var')		numnoiselevels = 7;	else		numnoiselevels = length(noiselevels);	end	% the stimulus levels to test	if ~exist('noiselevels','var')		noiselevels = logspace(log10(noiserange(1)),log10(noiserange(2)),numnoiselevels);		end	% error checking	if length(approxthresh) < numnoiselevels		printstr('number of noise levels and threshold estimates do not match.');		break;	end	% constants	fileshareoff = 1;	calfile = 'AppleA.DDF';	duration = 2;	darktime = 120;	vd = 100;	lettersize = 32;	font = 'times';	key1 = abs('1');	key2 = abs('2');	maxrows = 3;	maxcols = 3;	basefixation = ones(4)*3;	randfixation = basefixation*250;	% make sounds	introsnd=makesnd(140,.2,.5);	corrsnd=makesnd(400,.09,.5);	wrongsnd=makesnd(200,.09,.5);		% open the screens	tempCLUT=ones(256,3)*160;	tempCLUT(2,:)=[1 1 1];	[screens,rects] = openscreens(mainscrs,tempCLUT);	[oldfont,oldsz,oldstyle] = settext(screens(1),font,26,1);	[newx,newy] = centertext(screens(1),rects(1,:),'Pause For Adaptation'); tic;	% get the calibration data	[cal1] = getddf(calfile);	% hide the cursor;	hidecursor;		% load stimuli	load allletterstruct;	names = fieldnames(images);	numstim = length(names);	eval(['imagesz = size(images.',names{1},');']);	if uncertainty		nzsz = [lettersize*maxrows,lettersize*maxcols];	else		nzsz = [lettersize,lettersize*numshow];	end		% resize the images and average their amplitude spectra	images = shrinkimages(images,lettersize/max(imagesz));	images = avemag(images,.1);	eval(['[temp,tempCLUT] = makeimage(images.',names{1},',cal1);']);		% make file names	found = 0;	loc = 1;	while ~found		if numsessions > 1			filename = [name,num2str(loc),'eqnoisememcon'num2str(round(soa*1000)),noisetype,'.dat'];		else			filename = [name,num2str(loc),'eqnoisemem',num2str(round(soa*1000)),noisetype,'.dat'];		end		if ~(exist(filename)==2)			found = 1;		else			loc = loc+1;		end	end		% the stimulus levels to test	for i=1:numnoiselevels		stimlevels(:,i) = logspace(log10(approxthresh(i)./10^(logrange/2)),log10(approxthresh(i).*10^(logrange/2)),numstimlevels)';	end		% open the data file and write the header	if exist(filename) ~= 2		fwid = fopen(filename,'a+');					savecomment(fwid,['Data File Name: ',filename]);		savecomment(fwid,'eqnoisemem experiment');		savecomment(fwid,['image names: ',strcat(names{1:end})]);		savecomment(fwid,['calibration file: ',calfile]);		savecommand(fwid,['viewingdistance = ',num2str(vd),'; resolution = [',num2str(rects(1,3)),',',num2str(rects(4)),']; gam = .5;']);		savecommand(fwid,['font = ',quotestring(font),'; lettersize = ',num2str(lettersize),'; soa = ',num2str(soa),';']); 		savecommand(fwid,['duration = ',num2str(duration),'; darktime = ',num2str(darktime),';trials = ',num2str(maxtrials),';']);		savecommand(fwid,'trial = 1; sequence = 2; response = 3; correct = 4; stimlevel = 5; condition = 6; rt = 7; randnstate1 = 8; randnstate2 = 9;');		savedatetime(fwid);	else		fwid = fopen(filename,'a+');					savedatetime(fwid);	end	% turn off filesharing	if fileshareoff		status=fs('Off');	end		% continue dark adptation	hidecursor;	done=toc;	togo=darktime-done;	passed=0;	start=GetSecs;	hit='9';	while getsecs-start < togo & abs(hit)~=48  	% zero key skips adaptation		if CharAvail			hit=getchar;		end	end		% keypress to continue	screen(screens(1),'FillRect',0);	flushevents('keyDown');	sound(introsnd);	screen(screens(1),'SetClut',tempCLUT,0);	[newx,newy] = centertext(screens(1),rects(1,:),'Hit Any Key To Start');	hit = getchar;	screen(screens(1),'FillRect',0);	% initialize	sequence = coinflip(maxtrials*numstimlevels*numnoiselevels,.5) + 1;	conlevel = zeros(size(sequence));	id = zeros(size(sequence));		% for the responses	responses = ones([length(sequence),numsessions]);	correct = responses;	totaltrials = maxtrials*numstimlevels*numnoiselevels*numsessions;	pausetrials = round(totaltrials/4);	counter = 1;	for session = 1:numsessions				% to store the random number seeds and make the trial source		if session == 1			seeds = {};			trialstring = '';			for i = 1:numnoiselevels				eval(['trialsrc',num2str(i),' = mkconstim(stimlevels(:,',num2str(i),'),inf,',num2str(i),');']);				trialstring = [trialstring,'trialsrc',num2str(i),','];			end			eval(['trialsrc = mktslist(',trialstring(1:end-1),');']);		else			savecomment(fwid,['session #',num2str(session)]);			savedatetime(fwid);		end				% main loop		for trial = 1:totaltrials/numsessions  					if session == 1				% get the next stimulus level				[trialsrc,conlevel(trial),id(trial)] = gettrial(trialsrc);			end						% make the image			if session == 1				seeds{trial} = randn('state');			else				randn('state',seeds{trial});			end						nz=cliprandn(nzsz);					nz=nz*sqrt(noiselevels(id(trial))/std(nz(:))^2);			letters = randperm(26) + 96;			showletters = letters(randperm(numshow));			randletters = randperm(numshow);			currimage = [];			currimage = placeimages(showletters,images,lettersize,maxrows,maxcols,conlevel(trial),uncertainty); 			currimage = currimage+nz;			[currimage,CLUT]=makeimage(currimage,cal1);			% selection window			eval(['trueletter = images.',showletters(randletters(1)),';']);			eval(['falseletter = images.',letters(numshow+1),';']);			if sequence(trial) == 1				selectimage = [trueletter,zeros(size(trueletter)),zeros(size(trueletter)),falseletter];			else				selectimage = [falseletter,zeros(size(trueletter)),zeros(size(trueletter)),trueletter];			end			[selectimage,selectclut] = makeimage(selectimage,cal1);			% see if user wants to pause			key = pollpause(screens(1),'0',num2str(totaltrials-counter));					% fixation			screen(screens(1),'SetClut',tempCLUT,0);			screen(screens(1),'PutImage',basefixation + randfixation*coinflip(1,.5));						waitsecs(.5);			% present the image			screen(screens(1),'SetClut',CLUT,0);			screen(screens(1),'PutImage',currimage);			waitsecs(duration);			screen(screens(1),'FillRect',0);			waitsecs(soa);			% present the selection window			% a rect is defined as rect = [left,top,right,bottom].			screen(screens(1),'SetClut',selectclut,0);				screen(screens(1),'PutImage',selectimage,[rects(1,3)/2-lettersize*2,50,rects(1,3)/2+lettersize*2,lettersize+50]);						% get the response			time1 = getsecs;			flushevents('keyDown');			resp = '9';			while abs(resp)~= key1 & abs(resp)~=key2 & ~isquitkey(resp)				resp = getchar;				rt = getsecs-time1;			end			if abs(resp)==key2				responses(trial) = 2;			elseif isquitkey(resp)				sound(introsnd);				closeall;				return;			end					% clear the screen			screen(screens(1),'FillRect',0);				% accuracy			correct(trial,session)=sequence(trial)==responses(trial,session);			if correct(trial,session)				sound(corrsnd);			else				sound(wrongsnd);			end					% save the data			data=[trial,sequence(trial),responses(trial,session),correct(trial,session),conlevel(trial),noiselevels(id(trial)),rt,(seeds{trial})'];			fprintf(fwid,'%g\t',data); 			fprintf(fwid,'\n');			if session == 1				% update trial source				trialsrc = telltrial(trialsrc,conlevel(trial),correct(trial,session));			end					% increment			counter = counter+1;					end					end	% close the screen.	sound(introsnd);	screen CloseAll;		% close the file	fclose(fwid);		else		printstr('Not enough input arguments.')endreturn