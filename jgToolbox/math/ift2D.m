function [outmatrix] = ift2D(inmatrix)% function [outmatrix] = ft2D(inmatrix)%% Computes the discrete inverse Fourier transform of an m x n matrix % [inmatrix]. m and n can be any odd or even integers. The inverse transform% is returned in a real matrix [outmatrix] . The organization of the frequencies% for the [inmatrix] should be:%									+%								   pos%									:%									:%				    - neg...........DC............pos +%									:%									:%								   neg%									-%% If the image size is odd, the DC component should be centered in the % transform. If the image size is even, the DC component should be at the% (center+1,center+1) location. The inverse transform is computed by first % taking inverse transform of each column, then the inverse transform of each% row of the matrix from the first result.%% April 16, 1997   J Gold J Hillis  U of Toronto Vision Lab.  sz = size(inmatrix);			% The size of the matrix.n = sz(2);						% The number of points in each column vector.m = sz(1);						% The number of points in each row vector.if rem(n,2) == 1				% Make the indeces of the coefficients.	kc = [(-(n-1)/2):(n-1)/2]';	% If n is odd, this is kc.	else		kc = [(-n/2):(n/2-1)]';		% If n is even, this is kc.endif rem(m,2) == 1				% Make the indeces of the coefficients.	kr = [(-(m-1)/2):(m-1)/2]';	% If m is odd, this is kr.	else		kr = [(-m/2):(m/2-1)]';		% If m is even, this is kr.endLowerLimit = 1e-15;				% This is the cutoff for the amplitude								% of the components. If it is below								% this value, it is assumed to be zero.numfreqc = length(kc);			% The number of pos+neg freq's combined, column.numfreqr = length(kr);			% The number of pos+neg freq's combined, row.outmatrix = zeros(sz);			% Initialize the coefficient matrix.			tempmatrix = zeros(sz);			% Initialize the temp coefficient matrix.			tempvector = ones(1,n);kc = kc * tempvector;			% Create matrix with columns of coefficient indeces								% for discrete transform of columns.tempvectorR = ones(1,m);								kr = kr * tempvectorR;			% Create matrix with columns of coefficient indeces								% for discrete transform of rows.					indexc = (0:n-1);				% Indeces, for fast matrix multiplication.indexc = tempvector' * indexc;	% Create matrix with rows of indeces for								% partitioning along columns of inmatrix.exponentc = kc.* indexc;		% Rows of this matrix are the product of a column								% coefficient index (kc) and the column partition 								% index which is used in the sum (integral for 								% the non-discrete transform) of the product of 								% the function and the complex sinusoid for 								% f = kc - 1.indexr = 0:m-1;indexr = tempvectorR' * indexr;	% Create matrix with rows of indeces for								% partitioning along columns of inmatrix.exponentr = kr .* indexr;	% Compute the IFT1D's of the columns.for q = 1:n				tempmatrix(:,q) = [([inmatrix(:,q)]'*(exp((j*2*pi*exponentc)/n)))]';end% Compute the IFT1D's of the rows of the matrix with IFT1D's completed on% the columns.for q = 1:m				outmatrix(q,:) = (tempmatrix(q,:)*(exp((j*2*pi*exponentr)/m)));end% After computing the inverse Fourier transform there are some small complex values % left. We think this is due to rounding error. These small components are removed% for the final discrete inverse Fourier transform result.outmatrix = real(outmatrix);% END.	