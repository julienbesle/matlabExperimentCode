function [ PROB, IER, ERR ]=normmvcdf(M,K,H,R,EPS,CUT)% NORMMVCDF  Multivariate normal cumulative distribution function%% [ PROB, IER, ERR ]=normmvcdf(M,K,H,R,EPS,CUT)% 14-Sep-98 -- created (RFM)% DMV = NORMMVCDF%     ALGORITHM 725, COLLECTED ALGORITHMS FROM ACM.%     THIS WORK PUBLISHED IN TRANSACTIONS ON MATHEMATICAL SOFTWARE,%     VOL. 19, NO. 4, DECEMBER, 1993, P. 546.%     DMV CALCULATES THE MULTIVARIATE NORMAL INTEGRAL.%%     THE INTEGRAL LOWER LIMITS ARE -INFINITY FOR ALL VARIABLES.%     THE UPPER LIMITS ARE GIVEN BY THE VECTOR H (INPUT).%     THE CORRELATION MATRIX IS R (INPUT).%%     PARAMETERS:%%     M IS THE NUMBER OF VARIABLES. M<=20 (INPUT).%%     K IS A FLAG CONTROLLING THE INTEGRATION METHOD (INPUT).%       2<=K<=10 ONE GAUSIAN QUADRATURE WITH K POINTS FOR EACH%                VARIABLE IS PERFORMED. EPS IS DISREGARDED.%      12<=K<=20 PROGRESSIVE GAUSIAN QUADRATURES ARE PERFORMED FOR%                K=2,3,...,KMAX, WHERE KMAX IS 10 LESS THAN THE INPUT%                VALUE OF K, UNTIL THE DIFFERENCE BETWEEN THE%                CALCULATIONS FOR TWO SUCCESSIVE K'S DOES NOT EXCEED EPS.%                THE LAST VALUE OF K IS RETURNED IN IER.%                IF KMAX IS REACHED BEFORE A DIFFERENCE OF EPS IS%                ACHIEVED, THEN IER=0 AND THIS DIFFERENCE IS%                RETURNED IN ERR.%       EVERY OTHER K IS EQUIVALENT TO K=20.%%     H IS THE VECTOR OF UPPER LIMITS FOR THE INTEGRATION (INPUT).%%     R IS THE CORRELATION MATRIX DIMENSIONED R(20,20) (INPUT).%       IT MUST BE A SYMMETRIC, POSITIVE SEMI-DEFINITE MATRIX.%       THE CODE DOES NOT CHECK FOR THAT.%       IF R IS SINGULAR, NUMERICAL PROBLEMS MAY OCCUR.%%     EPS IS THE REQUIRED ERROR LIMIT (INPUT).%%     CUT - IF X<-CUT THEN EXP(X) IS IGNORED (ASSUMED ZERO).%           SUGGESTED VALUE CUT=15 (INPUT).%     PROB IS THE CALCULATED PROBABILITY (OUTPUT).%%     IER IS AN ERROR INDICATOR. ON NORMAL TERMINATION 0<IER<=10 IS THE%         VALUE OF K CORRESPONDING TO THE RETURNED VALUE PROB, (OUTPUT).%         IER=0 IS RETURNED WHEN THE ERROR IS GREATER THAN EPS.%         IER=98 MEANS AN ILLEGAL M VALUE (M SHOULD NOT EXCEED 20).%         IER=99 MEANS THAT R IS SINGULAR OR ITS DETERMINANT IS NEGATIVE.%%     ERR IS THE DIFFERENCE IN CALCULATING BY K-1 AND K. CALCULATED%         ONLY WHEN THE INPUT K>10 (OUTPUT).%PROB=0;IER=0;ERR=0;% use single K specified by userif (K>=2) & (K<=10),	[ PROB, IER ]=DMV1(M,K,H,R,CUT);	if IER==0,		IER=K;	end	returnend% step through K's from 2 up to K-10 until adequate convergence foundKMAX=10;if (K>11) & (K<21),	KMAX=K-10;endPOLD=-1;for KER=2:KMAX,	[ PROB, IER ]=DMV1(M,KER,H,R,CUT);	if IER>0,		return	end	IER=KER;	ERR=PROB-POLD;	if abs(ERR)<EPS,		return	end	POLD=PROB;endIER=0;returnfunction [ PROB, IER ] = DMV1( M, K, H, R, CUT )%     DMV1 CALCULATES THE PROBABILITY FOR A GIVEN K BY APPLYING%     THEOREM 1. IT CALLS SUBROUTINE SOLVE TO CALCULATE INDIVIDUAL%     VALUES BY (1) and (2).  DMV1 CAN BE CALLED DIRECTLY.%     K IS THE NUMBER OF POINTS IN THE GAUSS QUADRATURE (INPUT).%         IF K<2 OR K>10 THEN K IS SET TO 10.%     IER IS AN ERROR INDICATOR.%         IER=0 IS NORMAL TERMINATION.%         IER=98 INDICATES THAT M IS OUT OF RANGE.%         IER=99 MEANS THAT R IS SINGULAR OR ITS DETERMINANT IS NEGATIVE.%     THE OTHER VARIABLES ARE DESCRIBED ABOVE IN DMV.IER=0;if (M<0) | (M>20),	IER=98;	returnendPROB=0;%     WE EXPAND UP TO 2 TO THE POWER OF M TERMS DESCRIBED IN THEOREM 1.%     THE VECTOR LIST REPRESENTS THE "+" "-" AND INFINITY IN THE TERM.%     LIST(I) HAS THE VALUE OF 0 IF H(I)<=0, 1 IF H(I)>0, AND%     THE VALUE OF 2 IF INFINITY IS USED AS THE UPPER LIMIT AND THE%     VARIABLE IS DROPPED FROM THE INTEGRATION.%     LIST1 IS THE LIST OF VARIABLES THAT PARTICIPATE IN THE%     INTEGRATION (THAT DO NOT HAVE INFINITY AS AN UPPER LIMIT).LIST=zeros(M,1);LIST(find(H>0))=1;loopagain=1;while loopagain,loopagain=0;IPOS=0;LIST1=find(LIST~=2);L=size(LIST1,1);if L~=0,	H1=H(LIST1);	POSIND=find(LIST(LIST1)==1);	H1(POSIND)=-H1(POSIND);	IPOS=mod(prod(size(POSIND)),2);	R1=R(LIST1,LIST1);	R1(POSIND,:)=-R1(POSIND,:);	R1(:,POSIND)=-R1(:,POSIND);end[ S, IER ]=SOLVE(L,K,H1,R1,CUT);if IER>0,	returnendPROB=PROB+ifso(IPOS==0,S,-S);for I=1:M,	if LIST(I)~=0,		LIST(I)=LIST(I)+1;		if LIST(I)==2,			loopagain=1;			break		end		LIST(I)=1;	endendendreturnfunction [ S, IER ] = SOLVE(M,K,H,R,CUT)%     SOLVE CALCULATES THE MULTIVARIATE PROBABILITY OF A GIVEN VECTOR H%     AND GIVEN K.  SOLVE CAN BE CALLED DIRECTLY.%     ALL THE ARGUMENTS ARE AS DESCRIBED ABOVE IN DMV1 OR DMV.%     THE INTEGRATION PARAMETERS TAKEN FROM [8] HAVE 15 DIGITS ACCURACY.%     THE VECTORS COEF AND X CONTAIN THE GAUSS QUADRATURE COEFFICIENTS%     AND POINTS RESPECTIVELY AND ARE OBTAINED FROM [6].COEF=[ zeros(1,10), .6405291796843790,.245697745768379, zeros(1,8), ...     .446029770466658,.396468266998335,4.37288879877644e-2, zeros(1,7), ...     .325302999756919,.421107101852062,.133442500357520, ...     .637432348625728e-2,zeros(1,6),.248406152028443,.392331066652399, ...     .211418193076057,.332466603513439e-1,.824853344515628e-3,zeros(1,5), ...     .196849675488598,.349154201525395,.257259520584421, ...     .0760131375840057,.685191862513596e-2,9.84716452019267e-5, ...     zeros(1,4),.160609965149261,.306319808158099,.275527141784905, ...     .120630193130784,.0218922863438067,.00123644672831056, ...     1.10841575911059e-5,zeros(1,3),.13410918845336,.26833075447264, ...     .275953397988422,.15744828261879,.0448141099174625, ...     .00536793575602526,2.02063649132407e-4,1.19259692659532e-6, ...     zeros(1,2),.114088970242118,.235940791223685,.266425473630253, ...     .183251679101663,.0713440493066916,.0139814184155604, ...     .00116385272078519,.305670214897831e-4,1.23790511337496e-7, ...     0,0.0985520975191087,.208678066608185,.252051688403761, ...     .198684340038387,.097198422760062,.0270244164355446, ...     .00380464962249537,2.28886243044656e-4,4.34534479844469e-6, ...     1.24773714817825e-8 ];COEF=reshape(COEF,10,10);X=[ zeros(1,10),.300193931060839,1.25242104533372,zeros(1,8), ...     .190554149798192,.848251867544577,1.79977657841573,zeros(1,7), ...     .133776446996068,.624324690187190,1.34253782564499, ...     2.26266447701036,zeros(1,6),.100242151968216,.482813966046201, ...     1.06094982152572,1.77972941852026,2.66976035608766,zeros(1,5), ...     .0786006594130979,.386739410270631,.866429471682044, ...     1.46569804966352,2.172707796939,3.03682016932287,zeros(1,4), ...     .0637164846067008,.318192018888619,.724198989258373, ...     1.23803559921509,1.83852822027095,2.53148815132768, ...     3.37345643012458,zeros(1,3),.0529786439318514,.267398372167767, ...     .616302884182402,1.06424631211623,1.58885586227006, ...     2.18392115309586,2.86313388370808,3.6860071627244,zeros(1,2), ...     .0449390308011934,.228605305560535,.532195844331646, ...     .927280745338081,1.39292385519588,1.91884309919743, ...     2.50624783400574,3.17269213348124,3.97889886978978,0, ...     .0387385243257289,.198233304013083,.465201111814767, ...     .816861885592273,1.23454132402818,1.70679814968913, ...     2.22994008892494,2.80910374689875,3.46387241949586, ...     4.25536180636608 ];X=reshape(X,10,10);S=0;IER=0;if (M<0) | (M>20),	IER=20;	returnendif (K<2) | (K>10),	K=10;endif M<=0,	S=1;	IER=0;	returnendR1=inv(R);RDET=det(R);if RDET<=1e-30,	IER=99;	returnend% THIS LOOP CATERS TO THE POSSIBILITY% THAT THE INVERSE IS STORED ONLY IN THE LOWER TRIANGLE%for I=1:M,%	for J=I:M,%		R1(J,I)=R1(I,J);%	end%endSPROD=1;H1=sqrt(2./diag(R1));H2=H./H1;LIST(1:M)=1;for I=1:M,	SPROD=SPROD*pi*R1(I,I);endSPROD=1/sqrt(RDET*SPROD);R1=0.5*R1.*(H1*(H1'));S=0;loopagain=1;while loopagain,loopagain=0;SSUM=sum(X(LIST(1:M),K).*X(LIST(1:M),K));Y(1:M)=(X(LIST(1:M),K)-H2(1:M));Y=reshape(Y,M,1);SSUM=SSUM-sum(sum( (Y*(Y')).*R1 ));if SSUM>=-CUT,	SSUM=exp(SSUM);	SSUM=SSUM*prod(COEF(LIST(1:M),K));	S=S+SSUM;endfor I=1:M,	LIST(I)=LIST(I)+1;	if LIST(I)<K,		loopagain=1;		break	end	LIST(I)=1;endendS=S*SPROD;return