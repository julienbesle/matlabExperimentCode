function [outmatrix] = ft2D(inmatrix)% function [outmatrix] = ft2D(inmatrix)%% Computes the discrete Fourier transform of the 2D vector [inmatrix].% [inmatrix] can have odd or even rows and columns, as well as unequal% numbers of rows and columns. The transform is returned in a matrix% [outmatrix], in complex form. The organization of the frequencies% is as follows:%									+%								   pos%									:%									:%				    - neg...........DC............pos +%									:%									:%								   neg%									-%% If the image size is odd, the DC component will be centered in the % transform. If the image size is even, the DC component appears at the% (center+1,center+1) location. The transform is computed by fist taking% the 1D transform of eack column, then the 1D transform of each% column in the first result.%% April 14, 1997   J Gold J Hillis  U of Toronto Vision Lab.  % July 13, 1998:  JMG Fixed rounding function to single statement.sz = size(inmatrix);			% The size of the matrix.n = sz(2);						% The number of points in each column vector.m = sz(1);						% The number of points in each row vector.LowerLimit = 1e-15;				% This is the cutoff for the amplitude								% of the components. If it is below								% this value, it is assumed to be zero.if rem(n,2) == 1				% Make the indeces of the coefficients.	kc = [(-(n-1)/2):(n-1)/2]';	% If n is odd, this is kc.	else		kc = [(-n/2):(n/2-1)]';		% If n is even, this is kc.endif rem(m,2) == 1				% Make the indeces of the coefficients.	kr = [(-(m-1)/2):(m-1)/2]';	% If m is odd, this is kr.	else		kr = [(-m/2):(m/2-1)]';		% If m is even, this is kr.endnumfreqc = length(kc);			% The number of pos+neg freq's combined, column.numfreqr = length(kr);			% The number of pos+neg freq's combined, row.outmatrix = zeros(sz);			% Initialize the coefficient matrix.			tempmatrix = zeros(sz);			% Initialize the temp coefficient matrix.			tempvector = ones(1,n);kc = kc * tempvector;			% Create matrix with columns of coefficient indeces								% for discrete transform of columns.tempvectorR = ones(1,m);								kr = kr * tempvectorR;			% Create matrix with columns of coefficient indeces								% for discrete transform of rows.					indexc = (0:n-1);				% Indeces, for fast matrix multiplication.indexc = tempvector' * indexc;	% Create matrix with rows of indeces for								% partitioning along columns of inmatrix.exponentc = [kc.* indexc]';indexr = 0:m-1;indexr = tempvectorR' * indexr;	% Create matrix with rows of indeces for								% partitioning along columns of inmatrix.exponentr = [kr .* indexr]';	% Compute the FT1D's of the columns.for q = 1:n				tempmatrix(:,q) = [1/n*([inmatrix(:,q)]'*(exp((-j*2*pi*exponentc)/n)))]';end% Compute the FT1D's of the rows.for q = 1:m					outmatrix(q,:) = 1/m*(tempmatrix(q,:)*(exp((-j*2*pi*exponentr)/m)));end% Remove roundoff error.outmatrix(find(outmatrix<LowerLimit))=0;return