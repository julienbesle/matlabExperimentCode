function [outvector] = ift1D(invector)% function [outvector] = ift1D(invector)%% Computes the discrete inverse Fourier transform of the 1D vector [invector]% which is a fourier transform in complex form. [invector] can be odd or even.% The transform is returned in a row vector [outvector], with the complex% component dropped. The organization of the frequencies in the [invector]% should be as follows:%%				    - neg...........DC............pos +%% If [outvector] is odd, the DC component should be centered in the % transform. If the it is even, the DC component should appear at the% center+1 location. Also, assumed the coefficients have been divided by the% number of pixels in the image (as is the case for FT1D.m).%% April 14, 1997   J Gold J Hillis  U of Toronto Vision Lab.  n = length(invector);			% Ther number of points in the vector.if rem(n,2) == 1				% Make the indeces of the coefficients.	k = (-(n-1)/2):(n-1)/2;		% If n is odd, this is k.	else	k = (-n/2):(n/2-1);			% If n is even, this is k.endnumfreq = length(k);			% The number of pos+neg freq's combined.outvector = zeros(1,numfreq);	% Initialize the coefficient vector.			index = 0:n-1;					% Indeces, for fast matrix multiplication.% Compute the values in [outvector]. for i = 1:numfreq	outvector(i) = sum(invector.*(exp((j*2*pi.*k*index(i))/n)));end% Drop the imaginary part.outvector = real(outvector);% END.	