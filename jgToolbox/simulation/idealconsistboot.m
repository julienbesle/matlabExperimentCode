function [fits] = idealconsistboot(datafile) % function [fits] = idealconsistboot(datafile) %% simulations to relate the slope parameter of the% curves fit to consistency data to the internal/external% noise ratio%% the function fit to the consistency data is %%	pc = m*log10(pc)*100 + 100%% a simulated observer is given a task in various% levels of internal noise. the observer should have % 2 sets of repeated data. the consistency data are in the% data file [datafile], analyzed by the function 'doconsist.m'.% this should file should also contain the external noise% levels, internal noise levels, and number of trials per% stimulus level used in the simulation.%% for each i/e noise standard deviation ratio, bootstraps% are run to estimate the mean slope of the best fitting function% (above) and confidence intervals around the estimates.% this is done with the function 'consistboot.m'.% % after estimating the slope parameters, the relationship between% i/e ratio and slope m is well described by a 5 parameter% double exponential. a double exponential is fit to the data% with the function 'dblexpfitfun.m'. %% the resulting parameters from the fit can be used to estimate% i/e ratios for human observers by measuring the slope of the % consistency function.%% March 10, 2000 JMG% check for data fileif ~nargin	[datafile,folder] = uigetfile('*.cst','Choose File');endif datafile,		% number of interations per consistency bootstrap	numits = 500;		% get the file	data = readdata(datafile);		% number of internal noise levels	numnoise = length(internalnoisestd);		% only 1 external noise level	% internal and external noise levels should be	% stored as standard deviations	ieratio = internalnoisestd./externalnoisestd;		% number of stimulus levels; should be the same for all i/e ratios	numlevels = length(cond1pc);		% vector for number of trials per stimulus level	trials = ones(size(data,1))*ntrials;		% bootstrap for consistency fits	for i = 1:numnoise,				% get current data set		eval(['currdata = [data(:,cond',num2str(i),'pa),data(:,cond',num2str(i),'pc),trials];']);			% bootstrap		currfits = consistboot(currdata,numits,1);			% estimated slope		slopemean(i) = currfits.slopemean;			% estimated standard error		slopestd(i) = currfits.slopestd;		end		% fit double exponential to slope vs ie	dblexpfun = inline('params(1) + params(2).*exp(-params(3).*data) + params(4).*exp(-params(5).*data)','params','data');	slope2ieparams = dblexpfitfn([slopemean',ieratio',slopestd'],[0.114477 4.07001 0.013366 75.9068 0.0358296]);	ie2slopeparams = dblexpfitfn([ieratio',slopemean',slopestd'],[93.625 123.676 0.782677 352.647 6.48979]);		% plot fit	fitslope = linspace(slopemean(1),slopemean(end),1000);	fitieratio = dblexpfun(slope2ieparams,fitslope);	figure;loglog(slopemean,ieratio,'r*',fitslope,fitieratio,'b-')	xlabel('slope m (pc = m*log10(pa)*100 + 100)');	ylabel('i/e noise standard deviation');		% store data in structure for return	idealfits.numits = numits;	idealfits.slopemean = slopemean;	idealfits.slopestd = slopestd;	idealfits.internalnoisestd = internalnoisestd;	idealfits.externalnoisestd = externalnoisestd;	idealfits.ieratio = ieratio;	idealfits.slope2ieparams = slope2ieparams;	idealfits.ie2slopeparams = ie2slopeparams;	idealfits.fitfun = dblexpfun;	% save data to file	newfile = [datafile,'.mat'];	save(newfile,'idealfits');	endreturn