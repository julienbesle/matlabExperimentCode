function idealeffnz(maxtrials,stimfile,numstim,noiselevels,approxthresh,numsessions,numstimlevels,numshift,logrange,showstim,rotation,polarity,stimsize,ieSTDratio,endlabel)% function idealeffnz(maxtrials,stimfile,numstim,noiselevels,approxthresh,numsessions,numstimlevels,numshift,logrange,showstim,rotation,polarity,stimsize,ieSTDratio,endlabel)%% finds ideal thresholds in the noise masking experiment% uses method of constant stimuli%% March 1 2000  JMG  U of Toronto Vision Labif nargin > 1	% change directories to the main folder	cf;	jg local;		% defaults	defarg('maxtrials',40);	defarg('numstim',10);	defarg('stimfile','FaceStruct.mat');	defarg('noiselevels',0.0625);  % lo: 5e-4   hi:0.0625	defarg('numsessions',2);	defarg('numstimlevels',5);	defarg('rotation',0);	defarg('polarity','pos');	defarg('numshift',zeros(length(noiselevels)));	defarg('logrange',2);	defarg('approxthresh',2.5e-6);	defarg('showstim',[1:numstim]);		defarg('ieSTDratio',0);	defarg('endlabel','');	name = 'ideal';		% covert to numbers if necessary	checkstr(maxtrials);			% error checking	numnoiselevels = length(noiselevels);	if length(approxthresh) < numnoiselevels | length(numshift) ~= numnoiselevels		printstr('number of noise levels, threshold estimates, and shift factors do not match.');		return;	end		% constants	gam = 1/numstim;		% pc threshold	if gam == 0.1,		pc = 0.5;	else		pc = .75;	end		% seed the random number generator	clockseed = sum(100*clock);	randn('state',clockseed);		% load the stimulus file. stimuli are stored in the structure 'images'.	load(stimfile);	names = fieldnames(images);	numimages = length(names);		% reverse polarity ?	if strcmp(polarity,'neg')		for i = 1:numimages			eval(['images.',names{i},' = images.',names{i},'*-1;']);		end	end	% rotate ?	if rotation		if rotation == 180			for i = 1:numimages				eval(['images.',names{i},' = rot90(rot90(images.',names{i},'));']);			end		end	end	% adjust size ?	eval(['basesize = max(size(images.',names{1},'));']);	defarg('stimsize',basesize);		if stimsize ~= basesize		for i = 1:numimages,			eval(['images.',names{i},' = imresize(images.',names{i},',stimsize/basesize);']);		end			% recompute average amplitude spectrum		images = avemag(images,.1);	end	% error checking	if length(showstim) > numstim | sum(showstim>numimages)		printstr('number of stimuli and requested stimuli do not match.');		return;	end			% get requested images	if numimages ~= numstim				if numimages < numstim						error('Not enough images.')			return;		else			images = rmfield(images,names(setdiff([1:numimages],showstim)));		end	end	names = fieldnames(images);	eval(['imagesz = size(images.',names{1},');']);	nzsz = imagesz;		% the variance of all images is the same	eval(['basevar = std(images.',names{1},'(:))^2;']);		% make file names	found = 0;	loc = 1;		% stimulus type	if findstr('noise',lower(stimfile))		stimtype = 'text';	elseif findstr('letter',lower(stimfile))		stimtype = 'let';	elseif findstr('face',lower(stimfile))		stimtype = 'face';	else		stimtype = '';	end			while ~found		if numsessions > 1			filename = ['ideal',num2str(loc),stimtype,num2str(numstim),'ENZcon',polarity,num2str(rotation),endlabel,'.dat'];		else			filename = ['ideal',num2str(loc),stimtype,num2str(numstim),'ENZ',polarity,num2str(rotation),endlabel,'.dat'];		end		if ~(exist(filename)==2)			found = 1;		else			loc = loc+1;		end	end		% the stimulus levels to test	for i=1:numnoiselevels		shiftfactor = numshift(i)*(log10(approxthresh(i)*10^(logrange/2))-log10(approxthresh(i)/10^(logrange/2)))/(numstimlevels-1);		stimlevels(:,i) = logspace(log10(approxthresh(i)./10^(logrange/2))+shiftfactor,log10(approxthresh(i).*10^(logrange/2))+shiftfactor,numstimlevels)';	end		% open the data file and write the header	if exist(filename) ~= 2				% names		fwid = fopen(filename,'a+');					savecomment(fwid,['Data File Name: ',filename]);		savecomment(fwid,'efficiency & internal noise experiment');		savecomment(fwid,['image names: ',strcat(names{1:end})]);		% noise levels		savecommand(fwid,vars2str(numnoiselevels));		savecommand(fwid,vars2str(numstimlevels));		savecommand(fwid,vars2str(noiselevels));		savecommand(fwid,vars2str(ieSTDratio));				% stimulus parameters		savecommand(fwid,vars2str(clockseed));		savecommand(fwid,vars2str(showstim));		savecommand(fwid,vars2str(stimfile));		savecommand(fwid,vars2str(stimtype));		savecommand(fwid,vars2str(polarity));		savecommand(fwid,vars2str(rotation));		savecommand(fwid,vars2str(imagesz));		savecommand(fwid,vars2str(approxthresh));		savecommand(fwid,vars2str(numshift));		savecommand(fwid,vars2str(logrange));		% procedural parameters		savecommand(fwid,vars2str(maxtrials));		savecommand(fwid,vars2str(gam));		savecommand(fwid,vars2str(pc));				% tags for data columns		savecommand(fwid,'trial = 1; sequence = 2; response = 3; correct = 4; stimlevel = 5; condition = 6; internalnz = 7; randnstate1 = 8; randnstate2 = 9;');		% date and time		savedatetime(fwid);			else		fwid = fopen(filename,'a+');					savedatetime(fwid);	end			% initialize	sequence = rands([1:numstim],[1,maxtrials*numstimlevels*numnoiselevels]);	conlevel = zeros(size(sequence));	id = zeros(size(sequence));		% for the responses	responses = zeros([length(sequence),numsessions]);	correct = responses;	totaltrials = maxtrials*numstimlevels*numnoiselevels*numsessions;	pausetrials = round(totaltrials/4);	counter = 1;			% outer loop: sessions	fprintf(1,'\n\n\n')	for session = 1:numsessions				% to store the random number seeds and make the trial source		if session == 1			seeds = {};			trialstring = '';			for i = 1:numnoiselevels				eval(['trialsrc',num2str(i),' = mkconstim(stimlevels(:,',num2str(i),'),inf,',num2str(i),');']);				trialstring = [trialstring,'trialsrc',num2str(i),','];			end			eval(['trialsrc = mktslist(',trialstring(1:end-1),');']);		else			savecomment(fwid,['session #',num2str(session)]);			savedatetime(fwid);		end				% main loop: trials within sessions		fprintf(1,'\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n')		for trial = 1:totaltrials/numsessions  					if session == 1				% get the next stimulus level				[trialsrc,conlevel(trial),id(trial)] = gettrial(trialsrc);			end						% make the image			eval(['imagevar = stdm(images.',names{sequence(trial)},')^2;']); 						if session == 1				seeds{trial} = randn('state');			else				randn('state',seeds{trial});			end						externalnz=cliprandn(nzsz);			externalnz=externalnz*sqrt(noiselevels(id(trial))/stdm(externalnz)^2);			if ieSTDratio > 0,				internalnz=cliprandn(nzsz); 						internalnz=internalnz*sqrt(((sqrt((noiselevels(id(trial))+imagevar))*ieSTDratio).^2)/stdm(internalnz)^2);				eval(['currimage = images.',names{sequence(trial)},'.*sqrt(conlevel(trial)/imagevar) + externalnz + internalnz;']);			else				internalnz = 0;				eval(['currimage = images.',names{sequence(trial)},'.*sqrt(conlevel(trial)/imagevar) + externalnz;']);			end						% response			for cc = 1:length(names),				eval(['corr(cc) = sum(sum(images.',names{cc},'.*currimage));']);			end						% accuracy			responses(trial,session) = min(find(corr==max(corr)));			correct(trial,session) = sequence(trial)==responses(trial,session);					% echo to screen			fprintf(1,'\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\btrial %4d correct %4d',trial,correct(trial,session));						% save the data			data=[trial,showstim(sequence(trial)),showstim(responses(trial,session)),correct(trial,session),conlevel(trial),noiselevels(id(trial)),stdm(internalnz)^2];			fprintf(fwid,'%g\t',data); 			fprintf(fwid,'%.0f\t',(seeds{trial})');			fprintf(fwid,'\n');			% update trial source if first session			if session == 1				% update trial source				trialsrc = telltrial(trialsrc,conlevel(trial),correct(trial,session));			end								% increment counter			counter = counter+1;					end			fprintf(1,'\n');				end			% close the file	fclose(fwid);		% data analysis	else	% error feedback	printstr('Not enough input arguments.')endreturn