function gabor = dogaborcmp(cpi1,cpi2,cpw,sz,deg1,deg2,phz1,phz2)% function gabor = dogaborcmp(cpi1,cpi2,deg1,deg2,phz1,phz2,cpw,sz)%% makes a square 2d 2-component compound gabor (+/-2 sd Gaussian window)%% parameters:%	cpi1,cpi2	  -		the frequency of each component, inc cycles per image%	deg1,deg2	  -		(optional) the orientation of each component.%						default (and 0/180) is vertical. default and 90%						are fast; rotation is slow.%	phz1,phz2	  -		(optional) the phase of the components in degrees,% 						relative to sz/2+1. default (and 0) is + sine.%	cpw			  -		the number of cycles falling within the%						Gaussian window (+/- 2 standard deviations)%						the window is made relative to the lower frequency.%	sz			  - 	the nxn size of the final matrix, in pixels.%	% September 11, 1998  JMG U of T Vision Lab% default orientation is 0 deg (vertical)if nargin < 5 	deg1 = 0;end% default orientation is 0 deg (vertical)if nargin < 6 	deg2 = 0;end% default phase is 0 (+sine)if nargin < 7	phz1 = 0;else	phz1 = deg2rad(phz1);end	% default phase is 0 (+sine)if nargin < 8	phz2 = 0;else	phz2 = deg2rad(phz2);end		if nargin>3 	% params for the Gaussian; 4 standard deviations = cpw*wavelength	sigma =  (cpw*(sz/min(cpi1,cpi2)))/4;	center = sz/2+1;	gauss = dogauss2d(sz,sigma);	% make the first grating (note: in +sine phase, DC component is zero)	if abs(deg1)==90		gabor1 = sin(2*pi*cpi1*(((0:sz-1)-center)./sz)+phz1)'*ones(1,sz);	else		gabor1 = ones(1,sz)'*sin(2*pi*cpi1*(((0:sz-1)-center)./sz)+phz1);	end		% rotate if necessary	if deg1 ~= 0 & deg1 ~= 180 & abs(deg1)~=90		gabor1 = getcenter(imrotate(gabor1,deg1),sz,sz);	end			% make the first grating (note: in +sine phase, DC component is zero)	if abs(deg2)==90		gabor2 = sin(2*pi*cpi2*(((0:sz-1)-center)./sz)+phz2)'*ones(1,sz);	else		gabor2 = ones(1,sz)'*sin(2*pi*cpi2*(((0:sz-1)-center)./sz)+phz2);	end		% rotate if necessary	if deg2 ~= 0 & deg2 ~= 180 & abs(deg2)~=90		gabor2 = getcenter(imrotate(gabor2,deg2),sz,sz);	end		% the final gabor	gabor = gauss.*(gabor1+gabor2);else	% error handling	printstr('Not enough input arguments.');	gabor = -1;endreturn