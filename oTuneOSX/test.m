function [] = oTune(adapt)% modified by PJB 25-JAN-06defarg('adapt',60);%set sim flagsim = 0;%ask some things, initials for examplesubjectName = input('Subject initials: ','s');% Screen and stimulus paramaters.	display.main = 0;display.exp = 1;% display paramsnoscreen = -1;display.rect = [0 0 1024 768]; %resolution 1024 by 768display.center = [ (display.rect(1) + display.rect(3)) / 2 (display.rect(2) + display.rect(4)) / 2 ];stim.center = display.center;% display temporal paramsdisplay.Hz = 75; % refresh ratedisplay.frameDuration = 1 / display.Hz * 10^3; % frame duration in msres = NearestResolution(0, display.rect(3), display.rect(4), display.Hz);% oldRes=Screen(display.exp, 'Resolution', res);% need to change to 8-bit codefolder = pwd;file = 'Jane1024x768_Aug09.DDF'; % was Cal.DDFs=getddf(file, folder);pixSz = 8;val = 0;% max and min contrast that can be shown on the monitor:avgLum=s.lmaxminave(3);cmaxDisplay=(s.lmaxminave(1)-avgLum)/avgLum;cminDisplay=(s.lmaxminave(2)-avgLum)/avgLum;% open onscreen windowPrepareScreen(display.exp);[display.window, display.rect] = screen(display.exp, 'OpenWindow', val, display.rect, pixSz);%stimulus spatial parameters & create gaussian windowstim.sz = 256; % stimulus size in pixels, matix will be squarestim.rect = [0 0 stim.sz stim.sz];stim.sigma = 384;stim.pos = [ display.center(1) - stim.sz/2 display.center(2) - stim.sz/2 ] ;stim.posRect = [ stim.pos stim.pos(1) + stim.sz stim.pos(2) + stim.sz ];stim.x = linspace(-1, 1, stim.sz);stim.y = linspace(-1, 1, stim.sz)';% for gaussian window% stim.gaussWindow = scale(normpdf(stim.y, 0, stim.sigma/stim.sz) * normpdf(stim.x, 0, stim.sigma/stim.sz));stim.gaussWindow = circ2d(stim.sz/2); stim.gaussWindow(:,1) = []; stim.gaussWindow(1,:) = [];stim.posRect = centerrect(stim.rect, display.rect);% open offscreen windowsdisplay.fix = screen(display.exp, 'OpenOffscreenWindow', val, display.rect, pixSz);display.stim1 = screen(display.exp, 'OpenOffscreenWindow', val, stim.rect, pixSz);display.stim2 = screen(display.exp, 'OpenOffscreenWindow', val, stim.rect, pixSz);display.blank = screen(display.exp, 'OpenOffscreenWindow', val, stim.rect, pixSz);display.blankAll = screen(display.exp, 'OpenOffscreenWindow', val, display.rect, pixSz);% set fixation paramsfix.fixSize = 3;fix.fixRect = [ stim.center - fix.fixSize stim.center + fix.fixSize ];fix.fixColor = [2 254];% response keys tilde = 96;	delete = 8; space_bar = 32; escape = 27; %reset random number generatorsrand('state',sum(100*clock));% framestim.frameWidth = 6; % distance between frame and pattern patch, %NB can be changed to negative number to provide a better localization cue stim.frameRect = [ stim.posRect(1:2) - stim.frameWidth/2 stim.posRect(3:4) + stim.frameWidth/2 ];stim.frameColor = [2 254]; stim.nIntervals = 2; % 2IFC%notch valuesstim.lowfNotch = 1; % used to be 1stim.highfNotch = 128;stim.notchCent = 0;stim.orient1Notch = stim.notchCent - [0 15 30 45 60 75 80]; % these two are the real vectors for oTunestim.orient2Notch = stim.notchCent + [0 15 30 45 60 75 80]; %  for when you use notch2ts.nSrc = length(stim.orient2Notch);%pquest valuesguesses = 0.15*ones(size(stim.orient2Notch));guessesSD =  2*ones(size(stim.orient2Notch));threshLevel = .75;beta = 1.5;delta = .01;gamma = .5;mulstep = 1.25;range = 100;accuracy = .1;%practice settingsnumPTrials = 0; % should be 4 or sopContrast = .4;  %practice trial contrastpCounter = ones(ts.nSrc,1).*numPTrials;% max trial variablets.maxTrials = 45;for tmpVar = 1:ts.nSrc	ts.src(tmpVar) = questcreate(log10(guesses(tmpVar)), log10(guesses(tmpVar)+guessesSD(tmpVar)...		/guesses(tmpVar)),threshLevel, beta, delta, gamma, log10(mulstep), log10(range));end%stimulus temporal parametersfix.offset  = 38; % delay between fixation point offset and interval 1 onsetstim.duration = 15; % was 7 framesstim.delayDuration = 38; % was 37if sim	stim.duration = 1; 	stim.delayDuration = 1; end% general soundsbeep.ready = nicebeep(300, 100, 5, 0);beep.correct = nicebeep(400, 100, 5, 0);	beep.incorrect = nicebeep(100, 100, 10, 0);beep.correct = zeros(size(beep.correct));% snd interval soundbeep.amp = .3;beep.freq = 350;beep.duration = stim.duration / display.Hz * 1000;beep.theta = 2*pi * beep.freq * (beep.duration / 1000);beep.samples = (beep.duration / 1000)*22254.545454;beep.interval = beep.amp * sin(0:(beep.theta/beep.samples):beep.theta);%stimulus variables, stimulus bandwidthstim.lowf = 1;stim.highf = 128;stim.orient1 = 0;stim.orient2 = 180;stim.dim = stim.sz;%gabor paramsstim.cpw = 14; % SWG Aug14-2006: This is actually programmed backwards; cpw is supposed to be the smaller% +/-2 stdev's window, and cpi the cyles of the whole image (damping aside).  this works, though, because CPT % passed these two to the variable spots backward in dogabor (below).  I could fix it...stim.cpi = 7;stim.szGabor = 256;stim.degGabor = 90;stim.phzGabor = 0;stim.dimNotch = stim.sz;%noise variance%noise variancenzSD=.4; stim.nzVar = nzSD^2; %was 0.4^2 in original experiment% we use the following values to clip the noise% N.B. these values should be within the displayable contrast rangenzMax = 2.25*nzSD;nzMin = -2.25*nzSD;% if (nzMax>cmaxDisplay)% 	close all;% 	error('maximum noise value exceeds highest displayable contrast');% end;% if (nzMin<cminDisplay)% 	close all;% 	error('minimum noise value is less than the lowest displayable contrast');% end;	%initialize counter & stim.varcounter = 1;doneList = []; allDone = 0; stim.var = 0;%hide mousehidecursor;%blankmain;%make blankAll windowdisplay.blankAll = mkBlank(display.blankAll, stim.frameRect, stim, val); %open a sound channelsnd('Open');%instructions[im, clut] = pbmakeimage([-1 1],s); %make initial dummy clutscreen(display.window,'SetClut', clut); % set initial clutinstructions(display.window, display);screen('CopyWindow', display.blankAll, display.window);%adaptation codeif adapt > 0	[im, clut] = pbmakeimage([-1 1],s); %make initial dummy clut	screen(display.window,'SetClut', clut); % set initial clut	screen(display.window,'DrawText','Pausing for Adaptation',stim.center(1)-100,stim.center(2)-250,1);	WaitSecs(adapt);	snd('Play',beep.ready);	screen('CopyWindow', display.blankAll, display.window);endflushevents('keyDown');while ~isnan(stim.var) & counter <= (ts.maxTrials * ts.nSrc + numPTrials * ts.nSrc )	%get new threshold level if were in that sort of state, otherwise the same	whichID = unidrnd(ts.nSrc);	if pCounter(whichID) > 0 		stim.var = pContrast;		if pCounter == 3			stim.var = pContrast./2;		end;		if pCounter == 2			stim.var = pContrast./3;		end		if pCounter == 1			stim.var = pContrast./4;		end		practiceFlag = 1;		pCounter(whichID) = pCounter(whichID)-1;	else		stim.var = 10.^QuestMean(ts.src(whichID));		practiceFlag = 0;	end	%make fixation 	resVal = fix.fixColor(unidrnd(2)); % 	display.fix = mkFix(display.fix, fix.fixRect, stim); 	% make blanking window% 	display.blank = mkBlank(display.blank, stim.posRect, stim, val); 	% order variable and variance matrix	stim.testVar = [ stim.var 0 ];	trial.order = randperm(stim.nIntervals);		%stimulus generation loop	for tmpVar = 1 : stim.nIntervals				if stim.testVar(trial.order(tmpVar)) > 0 			% THE FOLLOWING BLOCK OF CODE IS NEW AND WAS ADDED BY PJB			tmpNoise=nzSD.*randn(stim.sz,stim.sz);			% we now find all of the contrast values that are out-of-range, recompute those values,			% and continue until all values are within the range that can be displayed on the monitor			alldone=0;			while alldone ~= 1				tmp=find( (tmpNoise(:)>nzMax) | (tmpNoise(:)<nzMin) );				if(length(tmp)<1)					alldone=1;					break;				else					newval=nzSD*randn(size(tmp));					tmpNoise(tmp)=newval;				end;			end;			eval(sprintf('trial.noise%i = tmpNoise;', tmpVar));			% END OF NEW NOISE CODE -- PJB		% 			eval(sprintf('trial.noise%i = randn(stim.sz, stim.sz);', tmpVar))			%take the FFT% 			eval(sprintf('noiseFFT = fft2(trial.noise%i);', tmpVar));						eval(sprintf('noiseFFT = fftshift(fft2(trial.noise%i));', tmpVar)); % must shift; dc in center of matrix						%get the amplitude spectrum% 			noiseAMP = abs(noiseFFT);			filtAMP = abs(noiseFFT); %test code										%filter the image% 			theFilter = filter2d(stim.lowf, stim.highf, stim.orient1, stim.orient2, stim.dim);% in "theNotchFilter" I changed notch2d to filter 2d for this band pass noise experiment Aug 2007			theFilter = 1;			theNotchFilter = notch2d(stim.lowfNotch, stim.highfNotch, stim.orient1Notch(whichID),...				stim.orient2Notch(whichID), stim.dim);							filtAMP = filtAMP .* theNotchFilter;						eval(sprintf('trial.noise%i = real(ifft2( ifftshift(filtAMP .* exp(-i * angle(noiseFFT)))));', tmpVar));%			COMMENT OUT NEXT LINE  SO THAT WE DON'T HAVE SAME VARIANCE IN ALL CONDITIONS% 			eval(sprintf('trial.noise%i = trial.noise%i .* sqrt(stim.nzVar ./ var(trial.noise%i(:)));', tmpVar, tmpVar, tmpVar));% 			%Fourier Transform Test code below%  			figure(1)			%  			eval(sprintf('imshow(scale(fftshift(abs(fft2(trial.noise%i)))))',tmpVar));%  			drawnow;			 			eval(sprintf('var(trial.noise%i(:))',tmpVar));						eval(sprintf('trial.noise%i = trial.noise%i + stim.testVar(trial.order(%i)).*dogabor(stim.cpw, stim.cpi, stim.szGabor, stim.degGabor, stim.phzGabor);', tmpVar, tmpVar, tmpVar));			%  			figure(2)			%  			eval(sprintf('imshow(scale(fftshift(abs(fft2(trial.noise%i)))))',tmpVar));%  			drawnow;% 			%code to get stimulus for talk purposes% 			eval(sprintf('testStim = trial.noise%i;', tmpVar));% 			save stimulusExample.mat testStim% 			break;					else			% THE FOLLOWING BLOCK OF CODE IS NEW AND WAS ADDED BY PJB			tmpNoise=nzSD.*randn(stim.sz,stim.sz);			% we now find all of the contrast values that are out-of-range, recompute those values,			% and continue until all values are within the range that can be displayed on the monitor			alldone=0;			while alldone ~= 1				tmp=find( (tmpNoise(:)>nzMax) | (tmpNoise(:)<nzMin) );				if(length(tmp)<1)					alldone=1;					break;				else					newval=nzSD*randn(size(tmp));					tmpNoise(tmp)=newval;				end;			end;			eval(sprintf('trial.noise%i = tmpNoise;', tmpVar));			% END OF NEW NOISE CODE -- PJB		% 			eval(sprintf('trial.noise%i = randn(stim.sz, stim.sz);', tmpVar));			%take the FFT			eval(sprintf('noiseFFT = fftshift(fft2(trial.noise%i));', tmpVar));						%get the amplitude spectrum			filtAMP =  abs(noiseFFT); %test code							%filter the image% 			theFilter = filter2d(stim.lowf, stim.highf, stim.orient1, stim.orient2, stim.dim);			theFilter = 1;			theNotchFilter = notch2d(stim.lowfNotch, stim.highfNotch, stim.orient1Notch(whichID),...				stim.orient2Notch(whichID), stim.dim);							filtAMP = filtAMP .*  theNotchFilter;			eval(sprintf('trial.noise%i = real(ifft2( ifftshift(filtAMP .* exp(-i * angle(noiseFFT)))));', tmpVar));			%code to get stimulus for talk purposes% 			eval(sprintf('testStim = trial.noise%i;', tmpVar));% 			save stimulusExample.mat testStim% 			eval(sprintf('trial.noise%i = trial.noise%i .* sqrt(stim.nzVar ./ var(trial.noise%i(:)));', tmpVar, tmpVar, tmpVar));					end				eval(sprintf('trial.noise%i = trial.noise%i .* stim.gaussWindow;', tmpVar, tmpVar));		%draw frame				eval(sprintf('screen(display.stim%i,''FrameRect'', 1, stim.frameRect);', tmpVar));		eval(sprintf('[trial.noise%i, trial.noiseClut%i] = pbmakeimage(trial.noise%i,s,resVal);', tmpVar, tmpVar, tmpVar));				eval(sprintf('screen(display.stim%i, ''PutImage'', trial.noise%i);', tmpVar, tmpVar));			end		stim.presStr = [...		'screen(display.window, ''WaitVBL'', 1);'...		'screen(display.window,''SetClut'', trial.noiseClut1);'...		'screen(display.window, ''WaitVBL'', 1);'...		'screen(''CopyWindow'', display.stim1, display.window, stim.rect, stim.posRect);'...		'screen(display.window, ''FrameOval'', 1, stim.frameRect);'...			'screen(display.window, ''WaitVBL'', stim.duration);'...		'screen(''CopyWindow'', display.blank, display.window, stim.rect, stim.posRect);'...		'screen(display.window, ''FrameOval'', 1, stim.frameRect);'...			'screen(display.window, ''WaitVBL'', stim.delayDuration);'...		'screen(display.window,''SetClut'', trial.noiseClut2);'...		'screen(''CopyWindow'', display.stim2, display.window, stim.rect, stim.posRect);'...		'screen(display.window, ''FrameOval'', 1, stim.frameRect);'...			'screen(display.window, ''WaitVBL'', stim.duration);'...		'screen(''CopyWindow'', display.blank, display.window, stim.rect, stim.posRect);'...		'screen(display.window, ''FrameOval'', 1, stim.frameRect);'];	%blank whole stimulus and wait 200ms	screen('CopyWindow', display.blankAll, display.window);	%make fixation	clut(2,:)=resVal*[1 1 1];% 	[im, clut] = pbmakeimage([-1 1],s,resVal); %make initial dummy clut	screen(display.window,'SetClut', clut); % set initial clut	display.fix = mkFix( display.fix, fix.fixRect, stim); 	%display fixation wait for key press the pause for 200ms	screen('CopyWindow', display.fix, display.window);	if ~sim		exitflag = waitforspace(0);	end	if exitflag		stim.var = NaN;	else		eraseFix(display.window, fix.fixRect);		screen(display.window, 'WaitVBL',fix.offset);		%rush code to the processor, but not really		rush(stim.presStr, 0);				    %screen(display.window, 'FrameOval', 1, stim.frameRect);		 	%Get response				if ~sim		 	response = 0;			while (response ~= tilde) & (response ~= delete)				flushevents('keyDown');				response = GetChar;			end			if response == tilde				response = [1 2];			else				response = [2 1];			end			if response == trial.order				correct = 1;				sound(beep.correct);			else				correct = 0;				sound(beep.incorrect);			end			end		if sim			[correct, curthreshold] = oTuneObserver(stim.orient1Notch(whichID),stim.orient2Notch(whichID),...				stim.notchCent,stim.var);			if correct				response = trial.order;				sound(beep.correct);			else				response = fliplr(trial.order);				sound(beep.incorrect);			end		end		%save trial id		data(counter, 1) = whichID;		data(counter, 2) = stim.var;		data(counter, 3) = correct;		data(counter, 4) = response(1);		data(counter, 5) = trial.order(1);		data(counter, 6) = practiceFlag;		%report trial		%	[ts.src(whichID)] = telltrial(ts.src(whichID), stim.var, correct);	    if ~practiceFlag			ts.src(whichID) = QuestUpdate(ts.src(whichID), log10(stim.var), correct);		end		counter = counter + 1;			%blank whole stimulus		screen('CopyWindow', display.blankAll, display.window);	end; % if exitflag else...endscreen('CloseAll');%close the sound channelsnd('Close'); for tmpVar = 1:ts.nSrc%	est(tmpVar) = threshest(ts.src(tmpVar));	est(tmpVar) = 10.^QuestMean(ts.src(tmpVar));	endest;cd('data');eval(sprintf('save %s.mat',subjectName));cd('..');return;function [window] = mkFix( window, fixRect, stim); 	screen(window, 'FillOval', 1, fixRect);	screen(window, 'FrameOval', 1, stim.frameRect);return;function [window] = eraseFix( window, fixRect); 	screen(window, 'FillOval', 0, fixRect);return;function [window] = mkBlank( window, blankRect, stim, val ); 	screen(window, 'FillRect', val, blankRect);return;function beep = mkSountrack( freq, duration, silenceDuration );	theta = 2*pi * freq * (duration / 1000);	samples = (duration / 1000)*22254.545454;	interval = sin(0:(theta/samples):theta);	silenceSamples = (silenceDuration / 1000) * 22254.545454;	silence = zeros(silenceSamples, 1);	beep = [interval silence interval];return;