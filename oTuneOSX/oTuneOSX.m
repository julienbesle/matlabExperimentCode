% oTuneOSX% this is oTune ported over from OS9 to OSX by SWG mid Jan 2008% most of the porting involved adapting to the OSX psychtoolbox Screen fxn% this port was done because, in the process of revising the oTune manuscript, we decided% it would be nice to use all 1770 lum levels available from the ddf file for the monitor% instead of using just 256.  the issue is with the luminance/contrast resolution% of the target at the narrowest notch widths where there is a large lum range of noise, this % spreads the 256 contrast values over a large range and the target, as the staircase% decreases its contrast, gets a smaller and smaller slice of those 256 grey levels being used.% In wide notches, apparently, the noise is of a smaller lum/contrast range, so the 256 grey% levels aren't spread out as much.  -SWG% small issue with circ2d.m; I had to rewrite it and it's offset by 1 pixel -SWGfunction [] = oTune(adapt)% modified by PJB 25-JAN-06defarg('adapt',3); % should be 60 (seconds)%set sim flagsim = 0;%ask some things, initials for examplesubjectName = input('Subject initials: ','s');% Screen and stimulus paramaters.	display.main = 0;display.exp = 1;% display paramsnoscreen = -1;display.rect = [0 0 1024 768]; %resolution 1024 by 768% display temporal paramsdisplay.Hz = 75; % refresh ratedisplay.frameDuration = 1 / display.Hz * 10^3; % frame duration in ms% res = NearestResolution(display.exp, display.rect(3), display.rect(4), display.Hz);% oldRes=Screen(display.exp, 'Resolution', res);% need to change to 8-bit codefolder = pwd;file = 'Jane1024x768_Aug09.DDF'; % was Cal.DDFs=getddf(file, folder);pixSz = 8;val = 0;% max and min contrast that can be shown on the monitor:avgLum=s.lmaxminave(3);cmaxDisplay=(s.lmaxminave(1)-avgLum)/avgLum;cminDisplay=(s.lmaxminave(2)-avgLum)/avgLum;calmatrix = s.calmatrix;scrinfo.params = s.ABKG; % I know I'm not being consistent with how I'm recording these... I'd rather just put it all in scrinfo. ... -SWG[RGBgrey,avgLum,avgLumIndex]=LtoRGB(avgLum,calmatrix);black = 0;white = 255;% Disable psychtoolbox test screen oldVisualDebugLevel = Screen('Preference', 'VisualDebugLevel', 3); oldSupressAllWarnings = Screen('Preference', 'SuppressAllWarnings', 1);% Open a double buffered fullscreen window and draw a gray background % to front and back buffers:numBuffers=2;[display.window, display.rect] = Screen('OpenWindow',0, 0,[],32,numBuffers);w=display.window; % for compatibility with some of PJB's codeScreen('FillRect',display.window, RGBgrey);Screen('Flip', display.window);Screen('FillRect',display.window, RGBgrey);Screen('Flip', display.window);center = [display.rect(3) display.rect(4)]/2;	% coordinates of screen center (pixels)% open onscreen window% PrepareScreen(display.exp);% [display.window, display.rect] = screen(display.exp, 'OpenWindow', val, display.rect, pixSz);display.center = [ (display.rect(1) + display.rect(3)) / 2 (display.rect(2) + display.rect(4)) / 2 ];stim.center = display.center;% fixation pointfixPntX = round( abs(display.rect(RectRight)-display.rect(RectLeft)) / 2 );fixPntY = round( abs(display.rect(RectBottom)-display.rect(RectTop)) / 2 );fixPntSize = 4;%stimulus spatial parameters & create gaussian windowstim.sz = 256; % stimulus size in pixels, matix will be squarestim.rect = [0 0 stim.sz stim.sz];stim.sigma = 384;stim.pos = [ display.center(1) - stim.sz/2 display.center(2) - stim.sz/2 ] ;stim.posRect = [ stim.pos stim.pos(1) + stim.sz stim.pos(2) + stim.sz ];stim.x = linspace(-1, 1, stim.sz);stim.y = linspace(-1, 1, stim.sz)';% for gaussian window% stim.gaussWindow = scale(normpdf(stim.y, 0, stim.sigma/stim.sz) * normpdf(stim.x, 0, stim.sigma/stim.sz));stim.gaussWindow = circ2daa(stim.sz/2); % stim.gaussWindow(:,1) = []; stim.gaussWindow(1,:) = [];stim.posRect = CenterRect(stim.rect, display.rect);% open offscreen windowsdisplay.fix = Screen('OpenOffscreenWindow',0,  val, display.rect, pixSz);display.stim1 = Screen('OpenOffscreenWindow',0, val, stim.rect, pixSz);display.stim2 = Screen('OpenOffscreenWindow', 0, val, stim.rect, pixSz);display.blank = Screen('OpenOffscreenWindow', 0, val, stim.rect, pixSz);display.blankAll = Screen('OpenOffscreenWindow', 0, val, display.rect, pixSz);% set fixation paramsfix.fixSize = 3;fix.fixRect = [ stim.center - fix.fixSize stim.center + fix.fixSize ];fix.fixColor = [2 254];% Set up response keyskb = GetKeyboardIndices; % list of keyboard indicesresponseKeyboard=max(kb); % my guess of which one we'll be using% % response keys % tilde = 96;	%% these may be the right numbers for on Jane?% delete = 8; % space_bar = 32; % escape = 27; tilde = 53;	 % these are them on my G5 for developingdelete = 42; space_bar = 44; escape = 41; goodKeys = [tilde, delete, space_bar, escape];escapeLocation = 4; %reset random number generatorsrand('state',sum(100*clock));% framestim.frameWidth = 6; % distance between frame and pattern patch, %NB can be changed to negative number to provide a better localization cue stim.frameRect = [ stim.posRect(1:2) - stim.frameWidth/2 stim.posRect(3:4) + stim.frameWidth/2 ];stim.frameColor = [2 254]; stim.nIntervals = 2; % 2IFC%notch valuesstim.lowfNotch = 1; % used to be 1stim.highfNotch = 128;stim.notchCent = 0;stim.orient1Notch = stim.notchCent - [0 15 30 45 60 75 80]; % these two are the real vectors for oTunestim.orient2Notch = stim.notchCent + [0 15 30 45 60 75 80]; %  for when you use notch2ts.nSrc = length(stim.orient2Notch);%pquest valuesguesses = 0.15*ones(size(stim.orient2Notch));guessesSD =  2*ones(size(stim.orient2Notch));threshLevel = .75;beta = 1.5;delta = .01;gamma = .5;mulstep = 1.25;range = 100;accuracy = .1;%practice settingsnumPTrials = 0; % should be 4 or sopContrast = .4;  %practice trial contrastpCounter = ones(ts.nSrc,1).*numPTrials;% max trial variablets.maxTrials = 45;for tmpVar = 1:ts.nSrc	ts.src(tmpVar) = QuestCreate(log10(guesses(tmpVar)), log10(guesses(tmpVar)+guessesSD(tmpVar)...		/guesses(tmpVar)),threshLevel, beta, delta, gamma, log10(mulstep), log10(range));end%stimulus temporal parametersfix.offset  = 38; % delay between fixation point offset and interval 1 onsetstim.duration = 15; % was 7 frames% timing variables  % Pat normally has 500ms fixpntduration and% stimoffsettime2, I think.  -SWGfixpntDuration = 0.1; % duration of fixation point, in secondsstimOffsetTime1 = 0.5; % delay, in seconds, between offset of fixation point and onset 1st stimulusstimDuration = 0.2; % stimulus duration in secondsisiDuration = 0.5; % ISI duration in secondsstimOffsetTime2 = 0.1; % delay, in seconds, between offset of 2nd stimulus and onset of fixation pointadaptDuration = 2; % Dark adaptation lengthstim.delayDuration = 38; % was 37if sim	stim.duration = 1; 	stim.delayDuration = 1; end% general soundsbeep.ready = nicebeep(300, 100, 5, 0);beep.correct = nicebeep(400, 100, 5, 0);	beep.incorrect = nicebeep(100, 100, 10, 0);beep.correct = zeros(size(beep.correct));% snd interval soundbeep.amp = .3;beep.freq = 350;beep.duration = stim.duration / display.Hz * 1000;beep.theta = 2*pi * beep.freq * (beep.duration / 1000);beep.samples = (beep.duration / 1000)*22254.545454;beep.interval = beep.amp * sin(0:(beep.theta/beep.samples):beep.theta);%stimulus variables, stimulus bandwidthstim.lowf = 1;stim.highf = 128;stim.orient1 = 0;stim.orient2 = 180;stim.dim = stim.sz;%gabor paramsstim.cpw = 14; % SWG Aug14-2006: This is actually programmed backwards; cpw is supposed to be the smaller% +/-2 stdev's window, and cpi the cyles of the whole image (damping aside).  this works, though, because CPT % passed these two to the variable spots backward in dogabor (below).  I could fix it...stim.cpi = 7;stim.szGabor = 256;stim.degGabor = 90;stim.phzGabor = 0;stim.dimNotch = stim.sz;%noise variance%noise variancenzSD=.4; stim.nzVar = nzSD^2; %was 0.4^2 in original experiment% we use the following values to clip the noise% N.B. these values should be within the displayable contrast rangenzMax = 2.25*nzSD;nzMin = -2.25*nzSD;% if (nzMax>cmaxDisplay)% 	close all;% 	error('maximum noise value exceeds highest displayable contrast');% end;% if (nzMin<cminDisplay)% 	close all;% 	error('minimum noise value is less than the lowest displayable contrast');% end;%initialize counter & stim.varcounter = 1; doneList = []; allDone = 0; stim.var = 0;%hide mouse% hidecursor;      %%%%%%%%%%%%%%%%%%%%%%blankmain;[VBLTimestamp StimulusOnsetTime FlipTimestamp Missed Beampos]=Screen('Flip', w); % flip displayScreen('DrawText',display.window,'Instructions go here.',center(1)-300,center(2)-50,[0 0 0]); Screen('DrawText', display.window, 'Press any key to continue...', center(1)-250, center(2)+50, [0 0 0]);[VBLTimestamp StimulusOnsetTime FlipTimestamp Missed Beampos]=Screen('Flip',display.window); % flip displayScreen('FillRect',w, RGBgrey); % clear screenwhile(GetSecs-VBLTimestamp < .5); % wait one secondend;KbWait; % wait for keypress[VBLTimestamp StimulusOnsetTime FlipTimestamp Missed Beampos]=Screen('Flip', w); % flip displayScreen('FillRect',w, RGBgrey); % clear bufferScreen('DrawText',w, 'Pause for 60 second dark adaptation',center(1)-320,center(2),[0 0 0]);[VBLTimestamp StimulusOnsetTime FlipTimestamp Missed Beampos]=Screen('Flip',w); % flip displayScreen('FillRect',w, RGBgrey); % clear bufferwhile(GetSecs-VBLTimestamp < adapt); % wait    [keyIsDown,secs,keyCode] = KbCheck;    if keyCode(escape)==1         break    endend Snd('Play',beep.ready);[VBLTimestamp StimulusOnsetTime FlipTimestamp Missed Beampos]=Screen('Flip', w); % flip display%make blankAll window% display.blankAll = mkBlank(display.blankAll, stim.frameRect, stim, val); % %open a sound channel% snd('Open');%instructions% [im, clut] = pbmakeimage([-1 1],s); %make initial dummy clut% screen(display.window,'SetClut', clut); % set initial clut% instructions(display.window, display);% screen('CopyWindow', display.blankAll, display.window);% %adaptation code% if adapt > 0% 	[im, clut] = pbmakeimage([-1 1],s); %make initial dummy clut% 	screen(display.window,'SetClut', clut); % set initial clut% 	screen(display.window,'DrawText','Pausing for Adaptation',stim.center(1)-100,stim.center(2)-250,1);% 	WaitSecs(adapt);% 	snd('Play',beep.ready);% 	screen('CopyWindow', display.blankAll, display.window);% endFlushEvents('keyDown');while ~isnan(stim.var) & counter <= (ts.maxTrials * ts.nSrc + numPTrials * ts.nSrc )	%get new threshold level if were in that sort of state, otherwise the same	whichID = unidrnd(ts.nSrc);	if pCounter(whichID) > 0 		stim.var = pContrast;		if pCounter == 3			stim.var = pContrast./2;		end;		if pCounter == 2			stim.var = pContrast./3;		end		if pCounter == 1			stim.var = pContrast./4;		end		practiceFlag = 1;		pCounter(whichID) = pCounter(whichID)-1;	else		stim.var = 10.^QuestMean(ts.src(whichID));		practiceFlag = 0;	end	%make fixation 	resVal = fix.fixColor(unidrnd(2)); % 	display.fix = mkFix(display.fix, fix.fixRect, stim); 	% make blanking window% 	display.blank = mkBlank(display.blank, stim.posRect, stim, val); 	% order variable and variance matrix 	stim.testVar = [ stim.var 0 ];	trial.order = randperm(stim.nIntervals);		%stimulus generation loop	for tmpVar = 1 : stim.nIntervals				if stim.testVar(trial.order(tmpVar)) > 0 			% THE FOLLOWING BLOCK OF CODE IS NEW AND WAS ADDED BY PJB			tmpNoise=.4.*randn(256,256); % changed to 256 from stim.nz, ZH			% we now find all of the contrast values that are out-of-range, recompute those values,			% and continue until all values are within the range that can be displayed on the monitor			alldone=0;			while alldone ~= 1				tmp=find( (tmpNoise(:)>nzMax) | (tmpNoise(:)<nzMin) );				if(length(tmp)<1)					alldone=1;					break; 				else					newval=nzSD*randn(size(tmp));					tmpNoise(tmp)=newval;				end;			end;			eval(sprintf('trial.noise%i = tmpNoise;', tmpVar));			% END OF NEW NOISE CODE -- PJB		% 			eval(sprintf('trial.noise%i = randn(stim.sz, stim.sz);', tmpVar))			%take the FFT% 			eval(sprintf('noiseFFT = fft2(trial.noise%i);', tmpVar));						eval(sprintf('noiseFFT = fftshift(fft2(trial.noise%i));', tmpVar)); % must shift; dc in center of matrix						%get the amplitude spectrum% 			noiseAMP = abs(noiseFFT);			filtAMP = abs(noiseFFT); %test code										%filter the image% 			theFilter = filter2d(stim.lowf, stim.highf, stim.orient1, stim.orient2, stim.dim);% in "theNotchFilter" I changed notch2d to filter 2d for this band pass noise experiment Aug 2007			theFilter = 1;			theNotchFilter = notch2d(1, 128, 0,180, 256);	%substituted by ZH nov 2009					        %    theNotchFilter = notch2d(stim.lowfNotch, stim.highfNotch, stim.orient1Notch(whichID),...		%		stim.orient2Notch(whichID), stim.dim);							filtAMP = filtAMP .* theNotchFilter;						eval(sprintf('trial.noise%i = real(ifft2( ifftshift(filtAMP .* exp(-i * angle(noiseFFT)))));', tmpVar));%			COMMENT OUT NEXT LINE  SO THAT WE DON'T HAVE SAME VARIANCE IN ALL CONDITIONS% 			eval(sprintf('trial.noise%i = trial.noise%i .* sqrt(stim.nzVar ./ var(trial.noise%i(:)));', tmpVar, tmpVar, tmpVar));% 			%Fourier Transform Test code below%  			figure(1)			%  			eval(sprintf('imshow(scale(fftshift(abs(fft2(trial.noise%i)))))',tmpVar));%  			drawnow;			 			eval(sprintf('var(trial.noise%i(:));',tmpVar));						eval(sprintf('trial.noise%i = trial.noise%i + stim.testVar(trial.order(%i)).*dogabor(stim.cpw, stim.cpi, stim.szGabor, stim.degGabor, stim.phzGabor);', tmpVar, tmpVar, tmpVar));			%  			figure(2)			%  			eval(sprintf('imshow(scale(fftshift(abs(fft2(trial.noise%i)))))',tmpVar));%  			drawnow;% 			%code to get stimulus for talk purposes% 			eval(sprintf('testStim = trial.noise%i;', tmpVar));% 			save stimulusExample.mat testStim% 			break;					else			% THE FOLLOWING BLOCK OF CODE IS NEW AND WAS ADDED BY PJB			tmpNoise=nzSD.*randn(stim.sz,stim.sz);			% we now find all of the contrast values that are out-of-range, recompute those values,			% and continue until all values are within the range that can be displayed on the monitor			alldone=0;			while alldone ~= 1				tmp=find( (tmpNoise(:)>nzMax) | (tmpNoise(:)<nzMin) );				if(length(tmp)<1)					alldone=1;					break;				else					newval=nzSD*randn(size(tmp));					tmpNoise(tmp)=newval;				end;			end;			eval(sprintf('trial.noise%i = tmpNoise;', tmpVar));			% END OF NEW NOISE CODE -- PJB		% 			eval(sprintf('trial.noise%i = randn(stim.sz, stim.sz);',% 			tmpVar));			%take the FFT			eval(sprintf('noiseFFT = fftshift(fft2(trial.noise%i));', tmpVar));						%get the amplitude spectrum			filtAMP =  abs(noiseFFT); %test code							%filter the image% 			theFilter = filter2d(stim.lowf, stim.highf, stim.orient1, stim.orient2, stim.dim);			theFilter = 1;			theNotchFilter = notch2d(stim.lowfNotch, stim.highfNotch, stim.orient1Notch(whichID),...				stim.orient2Notch(whichID), stim.dim);					filtAMP = filtAMP .*  theNotchFilter;			eval(sprintf('trial.noise%i = real(ifft2( ifftshift(filtAMP .* exp(-i * angle(noiseFFT)))));', tmpVar));			%code to get stimulus for talk purposes% 			eval(sprintf('testStim = trial.noise%i;', tmpVar));% 			save stimulusExample.mat testStim% 			eval(sprintf('trial.noise%i = trial.noise%i .* sqrt(stim.nzVar ./ var(trial.noise%i(:)));', tmpVar, tmpVar, tmpVar));					end				eval(sprintf('trial.noise%i = trial.noise%i .* stim.gaussWindow;', tmpVar, tmpVar));		%draw frame		%%% ACTUALLY, I MIGHT NEED THE BELOW LINE FOR THE		%CIRCLE FRAME - SWG 		%%% SWG not needed? eval(sprintf('screen(display.stim%i,''FrameRect'', 1, stim.frameRect);', tmpVar));		%%% SWG not needed? eval(sprintf('[trial.noise%i, trial.noiseClut%i] = pbmakeimage(trial.noise%i,s,resVal);', tmpVar, tmpVar, tmpVar));				%%% SWG not needed? eval(sprintf('screen(display.stim%i, ''PutImage'', trial.noise%i);', tmpVar, tmpVar));	                % convert from contrast to luminance        eval(sprintf('trial.noise%i = avgLum*(1+trial.noise%i);', tmpVar, tmpVar));        % convert from luminance to RGB values using bit-stealing method        eval(sprintf('trial.noise%i = Lum2RGB(trial.noise%i,calmatrix,scrinfo.params);', tmpVar, tmpVar));                % turn into a Screen Texture        eval(sprintf('trial.noise%i = Screen(''MakeTexture'',w, trial.noise%i);', tmpVar, tmpVar));            end%     stim.presStr = [...% 		'screen(display.window, ''WaitVBL'', 1);'...% 		'screen(display.window,''SetClut'', trial.noiseClut1);'...% 		'screen(display.window, ''WaitVBL'', 1);'...% 		'screen(''CopyWindow'', display.stim1, display.window, stim.rect, stim.posRect);'...% 		'screen(display.window, ''FrameOval'', 1, stim.frameRect);'...	% 		'screen(display.window, ''WaitVBL'', stim.duration);'...% 		'screen(''CopyWindow'', display.blank, display.window, stim.rect, stim.posRect);'...% 		'screen(display.window, ''FrameOval'', 1, stim.frameRect);'...	% 		'screen(display.window, ''WaitVBL'', stim.delayDuration);'...% 		'screen(display.window,''SetClut'', trial.noiseClut2);'...% 		'screen(''CopyWindow'', display.stim2, display.window, stim.rect, stim.posRect);'...% 		'screen(display.window, ''FrameOval'', 1, stim.frameRect);'...	% 		'screen(display.window, ''WaitVBL'', stim.duration);'...% 		'screen(''CopyWindow'', display.blank, display.window, stim.rect, stim.posRect);'...% 		'screen(display.window, ''FrameOval'', 1, stim.frameRect);'];% 	%blank whole stimulus and wait 200ms% 	screen('CopyWindow', display.blankAll, display.window);% 	%make fixation% 	clut(2,:)=resVal*[1 1 1];%     %[im, clut] = pbmakeimage([-1 1],s,resVal); %make initial dummy clut% 	screen(display.window,'SetClut', clut); % set initial clut% 	display.fix = mkFix( display.fix, fix.fixRect, stim); % 	%display fixation wait for key press the pause for 200ms% 	screen('CopyWindow', display.fix, display.window);% 	    % initialize display    Screen('FillRect',w, RGBgrey); % clear buffer    Screen('glPoint',w,black,fixPntX,fixPntY,fixPntSize); % draw fixation point    [VBLTimestamp StimulusOnsetTime FlipTimestamp Missed Beampos]=Screen('Flip', w); % flip display    Screen('FillRect',w, RGBgrey); % clear buffer    while(GetSecs-VBLTimestamp < fixpntDuration); % wait    end;             if ~sim  	 	exitflag = waitforspace(0);	end	if exitflag		stim.var = NaN;    else%         eraseFix(display.window, fix.fixRect);  %         screen(display.window, 'WaitVBL',fix.offset);% 		%rush code to the processor, but not really% 		rush(stim.presStr, 0);	%                 % present 1st interval            [VBLTimestamp StimulusOnsetTime FlipTimestamp Missed Beampos]=Screen('Flip', w); % flip display        Screen('DrawTexture', w, trial.noise1); %Draw face+noise array        Screen('FrameOval', w, black, stim.posRect,1,1);           while(GetSecs-VBLTimestamp < stimOffsetTime1); % wait        end;        [VBLTimestamp StimulusOnsetTime FlipTimestamp Missed Beampos]=Screen('Flip',w); % flip display        % prepare to erase screen        Screen('FillRect',w, RGBgrey); % clear screen        while(GetSecs-VBLTimestamp < stimDuration); % wait            end;        % erase        [VBLTimestamp StimulusOnsetTime FlipTimestamp Missed Beampos]=Screen('Flip',w); % flip display        % present 2nd interval        Screen('DrawTexture', w, trial.noise2); %Draw face+noise array        Screen('FrameOval', w, black, stim.posRect,1,1);           while(GetSecs-VBLTimestamp < isiDuration); % wait        end;        [VBLTimestamp StimulusOnsetTime FlipTimestamp Missed Beampos]=Screen('Flip',w); % flip display        % prepare to erase screen        Screen('FillRect',w, RGBgrey); % clear screen        while(GetSecs-VBLTimestamp < stimDuration); % wait        end;        % erase        [VBLTimestamp StimulusOnsetTime FlipTimestamp Missed Beampos]=Screen('Flip',w); % flip display        while(GetSecs-VBLTimestamp < stimOffsetTime2); % wait        end;        	    %screen(display.window, 'FrameOval', 1, stim.frameRect);  	 	%Get response				if ~sim		 	response = 0;			while (response ~= tilde) && (response ~= delete)				flushevents('keyDown');% 				response = GetChar;                response = pbGetKey(goodKeys,responseKeyboard); 			end			if response == tilde  				response = [1 2];            else				response = [2 1];			end			if response == trial.order				correct = 1;				sound(beep.correct);			else				correct = 0;				sound(beep.incorrect);			end			end		if sim			[correct, curthreshold] = oTuneObserver(stim.orient1Notch(whichID),stim.orient2Notch(whichID),...				stim.notchCent,stim.var);			if correct				response = trial.order;				sound(beep.correct);			else				response = fliplr(trial.order);				sound(beep.incorrect);			end		end		%save trial id		data(counter, 1) = whichID;		data(counter, 2) = stim.var;		data(counter, 3) = correct;		data(counter, 4) = response(1);		data(counter, 5) = trial.order(1);		data(counter, 6) = practiceFlag;		%report trial		%	[ts.src(whichID)] = telltrial(ts.src(whichID), stim.var, correct);	    if ~practiceFlag			ts.src(whichID) = QuestUpdate(ts.src(whichID), log10(stim.var), correct);		end		counter = counter + 1;			%blank whole stimulus		Screen('FillRect',w,RGBgrey);        Screen('Flip',w);%         screen('CopyWindow', display.blankAll, display.window);	end; % if exitflag else...endScreen('CloseAll');%restore default PTB warnings settingsScreen('Preference', 'VisualDebugLevel', oldVisualDebugLevel);Screen('Preference', 'SuppressAllWarnings', oldSupressAllWarnings);    %close the sound channelSnd('Close'); for tmpVar = 1:ts.nSrc%	est(tmpVar) = threshest(ts.src(tmpVar));	est(tmpVar) = 10.^QuestMean(ts.src(tmpVar));	endest;cd('data');eval(sprintf('save %s.mat',subjectName));cd('..');return;function [window] = mkFix( window, fixRect, stim); 	screen(window, 'FillOval', 1, fixRect);	screen(window, 'FrameOval', 1, stim.frameRect);return;function [window] = eraseFix( window, fixRect); 	screen(window, 'FillOval', 0, fixRect);return;% function [window] = mkBlank( window, blankRect, stim, val ); % 	screen(window, 'FillRect', val, blankRect);% return;function beep = mkSountrack( freq, duration, silenceDuration );	theta = 2*pi * freq * (duration / 1000);	samples = (duration / 1000)*22254.545454;	interval = sin(0:(theta/samples):theta);	silenceSamples = (silenceDuration / 1000) * 22254.545454;	silence = zeros(silenceSamples, 1);	beep = [interval silence interval];return;