function [data,constimrec,quitflag]=trialsthreshdisplayOSX(stimpix,displayrate,constimrec,mainscrs,thumbnail,facestim,exptdesign);% OS 9: function [data,constimrec,quitflag]=trialsthreshdisplayOSX(cal, stimpix,displayrate,constimrec,mainscrs,thumbnail,facestim,exptdesign);% function% [data,constimrec]=facethreshdisplay(cal,stimpix,displayrate,constimrec,ma% inscrs,facestim,exptdesign); removed cal for OSX version%warning('off','MATLAB:dispatcher:InexactMatch');MONTE_CARLO_SIM=0;% initialize the random number generatorrandn('state',sum(100*clock));% for playing sounds using 'snd'SND_RATE=8192;% data matrixdata=zeros(1,10); % dm: col 1 is staircase ID(1-4); col 2 is target contrast; col 3 is nzvar; col 4 is response;% set up response keys    kb = GetKeyboardIndices; % list of keyboard indices    responseKeyboard=max(kb); % my guess of which one we'll be using% These are the values for the response keyskey1 = abs('1'); % face 1key2 = abs('2'); % face 2key3 = abs('9'); % face 3key4 = abs('0'); % face 4escapekey = 48; % actually the zero key%escapekey = 27;% This is the value for the space bar, which is used to start each trial.spaceBar=32;deletekey=8;% convert stimulus duration from seconds to framesstimframes=round(displayrate*exptdesign.duration);fixpntoffsetframes=round(displayrate*exptdesign.fixpntstimoffset);if fixpntoffsetframes<1	fixpntoffsetframes=1;end;% make sounds for feedback, etc.introsnd=makesnd(600,.2,.6);intervalsnd=makesnd(300,exptdesign.duration,.6);corrsnd=makesnd(800,.09,.6);wrongsnd=makesnd(200,.09,.7);% calculate the max and min contrasts for this display OS9%L = cal.lmaxminave;%cmax=(L(1)-L(3))/L(3);%cmin=(L(2)-L(3))/L(3);load calfitrec;cmin=calfitrec.lmaxminave(2);cmax=calfitrec.lmaxminave(1);L=calfitrec.caldata(:,5);B=calfitrec.caldata(:,4);rgbMat=calfitrec.caldata(:,1:3);%OS 9%dcLUT=0;	% the rgb value for DC is stored in LUT index 0 (zero-based); for matlab, it is stored in array position #1%fixrgb=[0 0 0];	% the RGB value for the fixation point%fixLUT=1;	% the rgb value is stored in LUT index 1 (zero-based); for matlab, it is stored in array position #2%wordLUT=2;	% the rgb value for the stimulus word is stored in LUT index 2;% this makes an initial CLUT set to average luminance. In the calibration% routine, average luminance is arbitrarily chosen as the luminance % of the pixel combination [160 160 160]. you can change this easily.%tempCLUT=ones(256,3)*160;% this just stuffs a low-luminance value in the clut for text display.% it will be overwritten later on.%tempCLUT(2,:)=[1 1 1];% this is the screen upon which the image is to be displayexptdesign. defarg('mainscrs',0);AssertOpenGL; % added Nov 30/09 for compatibility with OSX, ZHnumBuffers=2;oldVisualDebugLevel = Screen('Preference', 'VisualDebugLevel', 3);oldSupressAllWarnings = Screen('Preference', 'SuppressAllWarnings', 1);    [w wrect]=Screen('OpenWindow',0, 0,[],32,numBuffers);    Screen('FillRect',w, [160 160 160]);    Screen('Flip', w);    center = [wrect(3) wrect(4)]/2;            ifi=Screen('GetFlipInterval', w);    waitframes = 1;    waitduration = waitframes * ifi;    % set text properties for our screen    TxtSize=32;    TxtSizeDiv2=round(TxtSize/2);    Screen('TextFont',w, 'Helvetica');    Screen('TextSize',w, TxtSize);    Screen('TextStyle', w, 0);    fixPntX = round( center(1));    fixPntY = round( center(2));    fixPntSize = 8;        priorityLevel=MaxPriority(w);       %OS9 STUFF    % this opens brainard's screen function. it is a wrapper% around the original function that can set mutiple screens% at once and sets unused screens to zero luminance.%[screens,rects] = openscreens(mainscrs,tempCLUT); %commented out this line nov 2009 ZH%fixpnt=setrect(0,0,8,8);fixpnt=CenterRect(fixpnt,rects(1,:));% stimrect=setrect(0,0,stimpix,stimpix);% destrect=CenterRect(stimrect,rects(1,:));% boxrect=setrect(0,0,stimpix+8,stimpix+8);% boxrect=CenterRect(boxrect,rects(1,:));%Setting up the rects OS X fixpnt=[0 0 8 8]; fixpnt=CenterRect(fixpnt, wrect); stimRect=[0 0 256 256]; destRect=CenterRect(stimRect, wrect); boxrect=[0 0 264 264]; boxrect=CenterRect(boxrect,wrect);% make dest rects for thumbnail images on response windowthumbsize=size(thumbnail(1).face);%thumbrect=setrect(0,0,thumbsize(2),thumbsize(1)); %OS 9thumbrect=[0,0,thumbsize(2),thumbsize(1)];thumbdest=zeros(4,4);for kk=1:exptdesign.numfaces	thumbdest(kk,:)=CenterRect(thumbrect,wrect);end;thumbdest(1,:)=offsetrect(thumbdest(1,:),round(-4*thumbsize(1)),round(-2*thumbsize(1)));thumbdest(2,:)=offsetrect(thumbdest(2,:),round(-2*thumbsize(1)),round(-2*thumbsize(1)));thumbdest(3,:)=offsetrect(thumbdest(3,:),round(0*thumbsize(1)),round(-2*thumbsize(1)));thumbdest(4,:)=offsetrect(thumbdest(4,:),round(2*thumbsize(1)),round(-2*thumbsize(1)));thumbdest(5,:)=offsetrect(thumbdest(5,:),round(4*thumbsize(1)),round(-2*thumbsize(1)));thumbdest(6,:)=offsetrect(thumbdest(6,:),round(-4*thumbsize(1)),round(2*thumbsize(1)));thumbdest(7,:)=offsetrect(thumbdest(7,:),round(-2*thumbsize(1)),round(2*thumbsize(1)));thumbdest(8,:)=offsetrect(thumbdest(8,:),round(0*thumbsize(1)),round(2*thumbsize(1)));thumbdest(9,:)=offsetrect(thumbdest(9,:),round(2*thumbsize(1)),round(2*thumbsize(1)));thumbdest(10,:)=offsetrect(thumbdest(10,:),round(4*thumbsize(1)),round(2*thumbsize(1)));% thumbdests for Drawtextures, OS Xthumbdests=zeros(4,10);for kk=1:10    thumbdests(:,kk)=thumbdest(kk,:);end;% numwindows=3;% offscrptrs=zeros(1,numwindows);% offscrptrs(1)=screen(mainscrs,'OpenOffscreenWindow',0,stimrect);	% offscreen window for face% create the off-screen windows for thumbnail images OS9%  for kk=1:exptdesign.numfaces%  	thumbnailptr(kk)=screen(mainscrs,'OpenOffscreenWindow',0,thumbrect);	% offscreen window for thumbnail image%   	screen(thumbnailptr(kk),'PutImage',thumbnail(kk).face); % store thumbnail face image in offscreen pixel map%  end; %create the textures for thumbnail images OS X  for kk=1:exptdesign.numfaces      thumbnailptr(kk)=Screen('MakeTexture', w, thumbnail(kk).face);      end;          % vector of thumbnailptrs for DrawTexture, OS X      thumbnailptrs=zeros(1,10);      for kk=1:10          thumbnailptrs(kk)=thumbnailptr(kk);      end            % create a clut and load it ---OS 9%defaultCLUT=[0:255]'*[1 1 1];%defaultCLUT(1,:)=[160,160,160]; % DC value in index 1%defaultCLUT(2,:)=fixrgb; % value for the fixation point & text%just making sure the display worksvbl=GetSecs;vblendtime = vbl + .5;while (vbl < vblendtime)Screen('DrawText', w, 'okay fine',100,200,0);[vbl]=Screen('Flip', w);end;%theKey=pbGetKey(spaceBar,responseKeyboard);%screen(screens(1),'SetClut',defaultCLUT,0);%screen(screens(1),'FillRect',0); % this fills the screen with clut index 0, which is [160 160 160]% start of the scan...hidecursor; % this hides the mouse cursorstarttime=GetSecs;% light adapt 0S9%adaptpause(screens(1),rects(1,:),exptdesign.adaptseconds);% light adapt OSXadaptpause(w,wrect,60,0);err=snd('Open'); % open the sound buffererr=snd('Play',introsnd,SND_RATE); err=snd('Play',corrsnd,SND_RATE); err=snd('Play',wrongsnd,SND_RATE);flushevents('keyDown'); % this flushes any key presses before this point.flushmouse;waitsecs(1);%OS9% screen(screens(1),'SetClut',defaultCLUT,0); % load clut% screen(screens(1),'FillRect',0); % clear the screen with average luminance% screen(screens(1),'FillOval',1,fixpnt); % draw fixation point% OSX Clear screen and show fixation point for 1 second    vbl=GetSecs;    vblendtime = vbl + 1;    while (vbl < vblendtime)    Screen('FillRect',w, [160 160 160]);    Screen('glPoint',w,0,fixPntX,fixPntY,8);    [vbl]=Screen('Flip', w); % flip the buffer to the screen    end    quitflag=0;alldone=0;curtrial=1;while ((alldone==0)&(quitflag==0))	stime=GetSecs; % get the start time for this trial; we'll use this later	curface=randomcondition(exptdesign.numfaces); % randomly select the faceID for this trial	gotone=0;	while (gotone==0)		condID=randomcondition(exptdesign.numnz);		if (~psyfuncfinished(constimrec(condID))) gotone=1; end;	end;		nzvar=constimrec(condID).appspec;	% noise variance	[stim,nzseed]=noise2d(stimpix,nzvar,-1,1,0);	curStimVariance=constimGetValue(constimrec(condID)); % get the stimulus variance for the current method-of-constant-stimuli record	tmpface=facestim(curface).face*sqrt(curStimVariance); % this formula works because the faces have a variance of 1	stim=stim+tmpface; % add noise to face    tmpfaceLum=65*(1+stim); % convert image from contrast to luminance values    tmpfaceBS=pbLum2BS(tmpfaceLum,L,B);  % bits-stealing     tmpfaceFinal=pbBitstealing2RGB(tmpfaceBS, rgbMat,0); % bit-stealing to RGB    dstRect=[0 0 256 256]; % destination rect    dstRect=CenterRect(dstRect, wrect); % dest rect centered    srcRect=[0 0 256 256]; % source rect, whatever that is    Stim=Screen('MakeTexture', w, tmpfaceFinal); % pre- DrawTexture preparation        trialStartTime=GetSecs;    gotime=stime+exptdesign.intertrial; % wait here		while (GetSecs<gotime) end;        time0=GetSecs;    timeStim=time0+.2;    while(time0<timeStim)    Screen('DrawTexture', w, Stim, srcRect, dstRect);  % actually putting the image on the screen    Screen('FrameRect', w, 10, boxrect, 1); % putting the frame around the stim on the screen    [time0]= Screen('Flip', w); % making it appear    end    stimofftime=GetSecs;        intTime=GetSecs;    intTime2=intTime+.100;    while intTime<intTime2        Screen('FillRect',w,[160 160 160])        intTime=Screen('Flip',w);    end;          %OS 9 method of converting image to CLUT values; replaced with OSX    %version above (lines after stim=stim+tmpface).    % this is the routine that makes a pixel image and a CLUT for display.	% the first index in the clut is always reserved for average luminance.	% remember that the routine expects the image in terms of *contrast*.	    %[currimage,currCLUT]=makeimage(stim,cal,0);  OS9 method of converting	%image, now using pbBitstealing for OSX	%screen(offscrptrs(1),'PutImage',currimage); % store in offscreen pixel map	         %   trialStartTime=GetSecs; %   gotime=stime+exptdesign.intertrial; % wait here	%	while (GetSecs<gotime) end;    % 	screen(screens(1),'WaitBlanking'); % wait 1 frame% 	screen(screens(1),'FillOval',0,fixpnt); % erase fixation point% 	screen(screens(1),'WaitBlanking',fixpntoffsetframes-1); % wait for the correct number of frames% 	screen(screens(1),'SetClut',currCLUT,0); % write to clut and return 1 frame later% 	screen(screens(1),'FrameRect',1,boxrect); % draw the stimulus box%   screen('CopyWindow',offscrptrs(1),screens(1),stimrect,destrect);% 	screen(screens(1),'WaitBlanking',stimframes); % wait for the correct number of frames% 	screen(screens(1),'FillRect',0,destrect); % fill destrect with avg lum% 	screen(screens(1),'FrameRect',0,boxrect); % erase the stimulus box% 	stimofftime=getsecs;% 	screen(screens(1),'WaitBlanking'); % wait 1 frame% 	screen(screens(1),'SetClut',defaultCLUT,0);% 	screen(screens(1),'FillOval',1,fixpnt); % draw fixation point    vbl=GetSecs;    vblendtime = vbl + 1;    while (vbl < vblendtime)    Screen('FillRect',w, [160 160 160]);    Screen('glPoint',w,0,fixPntX,fixPntY,8);    [vbl]=Screen('Flip', w);     end;        % draw thumbnail images OS 9	% for kk=1:exptdesign.numfaces	%    screen('CopyWindow',thumbnailptr(kk),screens(1),thumbrect,thumbdest(kk,:)); % copy the image to the screen		%end;                     %draw thumbnail images OS X        time1=GetSecs;        timeThumb=time1+.1;        while(time1<timeThumb)            Screen('DrawTextures', w, thumbnailptrs, thumbrect, thumbdests);            Screen('glPoint',w,0,fixPntX,fixPntY,8);            [time1]=Screen('Flip', w);        end;                    FlushEvents('keyDown');		FlushEvents('mouseDown');		FlushEvents('mouseUp');		% center the mouse on the fixation point		theX=fixpnt(rectleft)+round(rectwidth(fixpnt)/2);		theY=fixpnt(recttop)+round(rectheight(fixpnt)/2);		while 1			SetMouse(theX,theY);			[checkX,checkY] = GetMouse;			if (checkX==theX) & (checkY==theY)				break;			end		end		showcursor(0); gotresponse=0; response=0;		while (gotresponse==0)            %EventAvailTest; % OS X? Scrapped this bit			%[isavail,eventType]=eventavail('mouseDown','mouseUp'); %OS9			%if (isavail)				[clicks,x,y]=GetClicks(w);				for kk=1:exptdesign.numfaces					if (isinrect(x,y,thumbdest(kk,:)))						gotresponse=1; response=kk;					end; % if				end; % for		%	end; % if						if CharAvail				resp=abs(lower(GetChar));				if (resp==escapekey)					gotresponse=1;					quitflag=1;				end; % if (resp==escapekey)			end; %if charavail		end; % while		hidecursor; % this hides the mouse cursor		if quitflag==1 break; end;		% 		resp = 'y';% 		while abs(resp)~= key1 & abs(resp)~=key2 & abs(resp)~=key3 & abs(resp)~=key4 & abs(resp)~=escapekey% 			resp = lower(getchar);% 		end				rlatency=getsecs-stimofftime;		% 		switch abs(resp)% 			case key1% 				response=1;% 			case key2% 				response=2;% 			case key3% 				response=3;% 			case key4% 				response=4;% 			case escapekey% 				quitflag=1;% 				break;% 			otherwise% 				response=0;% 		end;		        % erase thumbnail images OS9		%for kk=1:exptdesign.numfaces		%	screen(screens(1),'FillRect',0,thumbdest(kk,:)); % fill destrect with avg lum		%end;		%screen(screens(1),'SetClut',defaultCLUT,0); % restore clut        %erase thumbnail images OSX        Screen('FillRect',w, [160 160 160]);        timeInterval=GetSecs;        timeInterval2=GetSecs+.500;        while timeInterval<timeInterval2            Screen('FillRect',w,[160 160 160]);            timeInterval=Screen('Flip',w);        end;                            	if (response > 0)		correct=(response==curface);		constimrec(condID)=psyfuncUpdate(constimrec(condID),correct); % update the constant stimuli data structure		if correct			% sound(corrsnd);			err=snd('Play',corrsnd,SND_RATE);		else			% sound(wrongsnd);			err=snd('Play',wrongsnd,SND_RATE);		end;	end; % if (response > 0) & (condID>0)		if (response>0)		data(curtrial,:)=[curtrial,condID,nzvar,curStimVariance,curface,response,correct,rlatency,nzseed']; % update data matrix		curtrial=curtrial+1; % increment trial counter	end; % if (response > 0)		% END OF TRIAL...	tmpdone=1;	for kk=1:exptdesign.numnz		if ~psyfuncfinished(constimrec(kk))			tmpdone=0;			break;		end;	end;	alldone=tmpdone;end; % while ((alldone==0)&(quitflag==0))err=snd('Close'); % close the sound buffer hereshowcursor(0);closeall;	% close the screen and data file. this is a wrapper around brainard that closes % all of the active windows and any text data file that may have been% opened but not closed during the routine.% sound(introsnd);return;