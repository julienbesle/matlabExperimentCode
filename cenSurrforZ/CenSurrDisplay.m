function [data,screc,quitflag]=CenSurrDisplay(stimparams,scrinfo,screc, exptdesign);try    DEBUG=0;    if(DEBUG==0)        HideCursor; % hide mouse    end;    %     oldResolution   = Screen('Resolution', scrinfo.number, scrinfo.width, scrinfo.height, scrinfo.framerate);    % initialize the random number generator    randn('state',sum(100*clock));    % set up response keys    kb = GetKeyboardIndices; % list of keyboard indices    responseKeyboard=max(kb); % my guess of which one we'll be using    % use pbGetKEY() to find out the number corresponding to a key    fKey=9;    jKey=13;    upKey = 82;    downKey = 81;    escapeKey = 41;    spaceBar = 44;    if exptdesign.whichKeys==4        fprintf('response keys are f=left j = right. Hit esc to escape\n');        goodKeys=[fKey jKey escapeKey]; % N.B. Escape key is in array location 5        escapeLocation=3;    end;    if exptdesign.whichKeys==6        fprintf('response keys are up arrow=up down arrow = down. Hit esc to escape\n');        goodKeys=[upKey downKey escapeKey]; % N.B. Escape key is in array location 5        escapeLocation=3;    end;    WaitSecs(1);    % make sounds for feedback, etc.    SND_RATE=8192;    corrsnd=makesnd(700,.3,.7,SND_RATE);    wrongsnd=makesnd(200,.3,.6,SND_RATE);%%  open/setup the screen    % ---------------    AssertOpenGL; % make sure we are using OpenGL    % Get the list of screens and choose the one with the highest screen number.    % Screen 0 is, by definition, the display with the menu bar. Often when    % two monitors are connected the one without the menu bar is used as    % the stimulus display.  Chosing the display with the highest dislay number is    % a best guess about where you want the stimulus displayed.    screens=Screen('Screens');    screenNumber=max(screens);    % Find the color values which correspond to white and black.  Though on OS    % X we currently only support true color and thus, for scalar color    % arguments,    % black is always 0 and white 255, this rule is not true on other platforms will    % not remain true on OS X after we add other color depth modes.    white=WhiteIndex(screenNumber);    black=BlackIndex(screenNumber);    gray=round((white+black)/2);    if gray==white        gray=black;    end    inc=white-gray;        RGBgrey = scrinfo.RGBgrey;    avgLum = scrinfo.avgLum;    L = scrinfo.L;     B = scrinfo.B;    rgbMat = scrinfo.rgbMat;    % Open a double buffered fullscreen window and draw a gray background    % to front and back buffers:    numBuffers=2;    [w wrect]=Screen('OpenWindow',screenNumber, 0,[],32,numBuffers);    Screen('BlendFunction', w, GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);    Screen('FillRect',w, RGBgrey);    Screen('Flip', w);    center = [wrect(3) wrect(4)]/2;	% coordinates of screen center (pixels)    ifi=Screen('GetFlipInterval', w);    waitframes = 1;    waitduration = waitframes * ifi;    % set text properties for our screen    TxtSize=32;    TxtSizeDiv2=round(TxtSize/2);    Screen('TextFont',w, 'Helvetica');    Screen('TextSize',w, TxtSize);    Screen('TextStyle', w, 0);    fixPntX = round( center(1));    fixPntY = round( center(2));    fixPntSize = 4;    % Clear screen    Screen('FillRect',w, RGBgrey);    Screen('Flip', w); % flip the buffer to the screen    priorityLevel=MaxPriority(w);    % wait for a keypress    if(DEBUG==0)        exptpause(w,wrect);        Screen('FillRect',w, RGBgrey);        Screen('Flip', w); % flip the buffer to the screen    end        % pause for light adaptation    if(DEBUG==0)        if exptdesign.curBlock == 1                    adaptpause(w,wrect,exptdesign.adaptseconds);                end    end    % Clear screen    Screen('FillRect',w, RGBgrey);%     Screen('glPoint',w,black,fixPntX,fixPntY,fixPntSize);    Screen('Flip', w); % flip the buffer to the screen%% SET UP FOR THIS CONDITION/BLOCK    curContrast=stimparams.contrast(exptdesign.curBlock);    curSFcpd = stimparams.sfcpd(exptdesign.curBlock);    curSFcpp = stimparams.sfcpp(exptdesign.curBlock);    cursizedeg = stimparams.sizedeg(exptdesign.curBlock);    gaussSD = stimparams.gaussSD(exptdesign.curBlock);            ppc = ceil(1/curSFcpp); %pixels per cycle%%% load constants used in expt.    numStaircases = length(screc); % number of staircases    gratingsize =  scrinfo.width*0.9;     texsize = floor(gratingsize/2);        visiblesize = 2*texsize+1;    pixelspersecond = stimparams.speedpps;    % initialize data vector    data=[];    % Definition of the drawn rectangle on the screen:    dstRect=[0 0 visiblesize visiblesize];    dstRect=CenterRect(dstRect, wrect);           % Create one single static grating image:        [gr_x]=meshgrid(-texsize:texsize + ppc, 1);  % 1D row of grating        cgrating = curContrast*cos(2*pi*curSFcpp*gr_x-rand*pi);        % With Bit Stealing            % convert from contrast to luminance:            cgratingLum=avgLum*(1+cgrating);            % convert Luminance to BitStealing Numbers:            cgratingBSnumbers=pbLum2BS(cgratingLum,L,B);            % finally, convert BS numbers to RGB values:            theGrating = pbBitStealing2RGB(cgratingBSnumbers,rgbMat,0);                                    % Store grating in texture:            GrTexture=Screen('MakeTexture', w, theGrating);                 % Make Gaussian Window Mask                        gray_layerLUM=avgLum*ones(2*texsize+1, 2*texsize+1);        [x,y]=meshgrid(-texsize:texsize,-texsize:texsize);                   % convert Luminance to BitStealing Numbers:       gray_layerBS =pbLum2BS(gray_layerLUM,L,B);            % finally, convert BS numbers to RGB values:       gray_layerRGB = pbBitStealing2RGB(gray_layerBS,rgbMat,0);       transp_layer= (1-exp(-( (x.^2+y.^2) / (2*(gaussSD^2)) ) ) ) ;  % white: 100% opaque,  black: 100% transparent%        trim = transp_layer>0.001;%        trim_transp_layer = trim.*transp_layer;      %        %        transp_layerLUM = scrinfo.maxLum*transp_layer;%        transp_layerBS =pbLum2BS( transp_layerLUM,L,B);%             % finally, convert BS numbers to RGB values:%        transp_layerRGB = pbBitStealing2RGB( transp_layerBS,rgbMat,0);              gab_maskRGBA = gray_layerRGB;       gab_maskRGBA(: , : , 4) = transp_layer*white;       gab_MskTexture=Screen('MakeTexture',w,gab_maskRGBA);  % mask texture              %% Show Instructionsif exptdesign.curBlock == 1Screen('DrawText', w, 'Welcome! ', center(1),100, black);Screen('DrawText', w, 'In this experiment, you will see a brief stimulus on every trial', 100, 200,black);Screen('DrawText', w, 'It will drift either to the Right or to the Left.', 100 , 250,black);Screen('DrawText', w, 'Please press R if it drifted to the Right and L if it drifted to the Left. ',100, 300,black);Screen('DrawText', w, 'Be as accurate as possible and remember to keep your eyes on the fixation point. ', 100, 350,black);Screen('DrawText', w, 'Press SPACE BAR to continue to the experiment. ', 100, 400, black); [VBLTimestamp]=Screen('Flip', w);theKey=pbGetKey(spaceBar,responseKeyboard);end Screen('FillRect',w, RGBgrey); Screen('glPoint',w,black,fixPntX,fixPntY,fixPntSize); Screen('Flip', w); % flip the buffer to the screen   % %% Do practice trials    quitflag=0;    practicetrial=1;    %Initialize Dependent Variable    curDuration=  exptdesign.practiceduration;        while ((practicetrial<= exptdesign.numpracticetrials)&&(quitflag==0))        trialStartTime=GetSecs; % mark the start of the trial%                % Translate requested speed of the grating (in cycles per second)        % into a shift value in "pixels per frame", assuming given        % waitduration: This is the amount of pixels to shift our "aperture" at        % each redraw:        shiftperframe= pixelspersecond * waitduration;                % wait until the start of the trial        while (GetSecs-trialStartTime < exptdesign.intertrial);           end;        Screen('glPoint',w,black,fixPntX,fixPntY,fixPntSize);        [VBLTimestamp]=Screen('Flip', w);        for kk=1:3   % flicker fixation point for 3 cycle at 10 Hz            Screen('glPoint',w,white,fixPntX,fixPntY,fixPntSize);	% paint white point            while(GetSecs-VBLTimestamp < 0.1)  ;            end;            [VBLTimestamp ]=Screen('Flip', w);            Screen('glPoint',w,black,fixPntX,fixPntY,fixPntSize); % paint black point            while(GetSecs-VBLTimestamp < 0.1)            end;            [VBLTimestamp ]=Screen('Flip', w);        end;        if ( GetSecs-VBLTimestamp > exptdesign.fixPntOffset )            disp('fixation offset error') % record error here        end;        while (GetSecs-VBLTimestamp < exptdesign.fixPntOffset)        end;        vbl = GetSecs;        vblendtime = vbl + curDuration;        i=0;        dir = (round(rand)); % 1 is right, 0 is left.        % Animationloop:        while(vbl < vblendtime)            % Shift the grating by "shiftperframe" pixels per frame:            xoffset = dir*ppc+((-1)^dir)*mod(i*shiftperframe,ppc);            %             xoffset = mod(i*shiftperframe,ppc);            i = i+1;            % Define shifted srcRect that cuts out the properly shifted rectangular            % area from the texture:            srcRect=[xoffset 0 xoffset + visiblesize visiblesize];            % Draw grating texture,:            Screen('DrawTexture', w, GrTexture, srcRect, dstRect, stimparams.angle);            % Draw gaussian mask over grating: We need to subtract 0.5 from            % the real size to avoid interpolation artifacts that are            % created by the gfx-hardware due to internal numerical            % roundoff errors when drawing rotated images:            Screen('DrawTexture', w,   gab_MskTexture, [0 0 visiblesize visiblesize], dstRect, stimparams.angle);            % Flip 'waitframes' monitor refresh intervals after last redraw.            vbl = Screen('Flip', w, vbl + (waitframes - 0.5) * ifi);        end        Screen('FillRect',w, RGBgrey); % fill next buffer with uniform grey        Screen('glPoint',w,black,fixPntX,fixPntY,fixPntSize);        [VBLTimestamp ]=Screen('Flip', w);        if stimparams.angle == 0 % right left            % draw the response window            L(1) = center(1) - TxtSizeDiv2 - 100;            R(1) = center(1) + 100;            L(2) = center(2) - TxtSizeDiv2;            R(2) = center(2) - TxtSizeDiv2;            Screen('DrawText', w, 'R', R(1), R(2),black);            Screen('DrawText', w, 'L', L(1), L(2),black);        elseif stimparams.angle == 90 % up down            % draw the response window            U(2) = center(2) - 100;            D(2) = center(2) - TxtSizeDiv2 + 100;            U(1) = center(1) - TxtSizeDiv2;            D(1) = center(1) - TxtSizeDiv2;            Screen('DrawText', w, 'U', U(1), U(2),black);            Screen('DrawText', w, 'D', D(1), D(2),black);        end%         while (GetSecs-VBLTimestamp < exptdesign.fixPntOffset)%         end;%                 Screen('glPoint',w,black,fixPntX,fixPntY,fixPntSize);        Screen('Flip', w); % draw response screen        % get response key        theKey=pbGetKey(goodKeys,responseKeyboard);        respLocation = find(goodKeys==theKey);        if (respLocation==escapeLocation)            quitflag=1;            break;        end;                correct=-1;        if (respLocation~=escapeLocation)            correct = (dir==1 && respLocation == 2) || (dir == 0 && respLocation ==1);            if exptdesign.usefeedback==1                if correct                    Snd('Play',corrsnd); % give auditory feedback for correct response                else                    Snd('Play',wrongsnd); % give auditory feedback for incorrect response                end;            end;        end; % if (response > 0)        Screen('FillRect',w, RGBgrey); % fill next buffer with uniform grey        Screen('glPoint',w,black,fixPntX,fixPntY,fixPntSize); % draw fixation point        Screen('Flip', w); %        if(correct)            curDuration = curDuration*0.8;        else            curDuration=curDuration*1.2;        end;        pdata(practicetrial, :) = [curContrast  curSFcpd cursizedeg gaussSD dir respLocation curDuration correct];          practicetrial=practicetrial+1; % increment trial counter    end; % while        %% Do real trials    alldone=0;    curtrial=1;    quitflag = 0;             while ((alldone==0)&&(quitflag==0))        trialStartTime=GetSecs; % mark the start of the trial%        % Set up Dependent Variable level        gotone=0;        while(gotone==0)            scID=randomcondition(numStaircases); % randomly select a staircase            if (~psyfuncfinished(screc(scID)))                gotone=1;            end;        end; % while        curStimLevel=psyfuncGetValue(screc(scID)); % get the duration from the current staircase record        curDuration=curStimLevel*ifi;               priorityLevel=MaxPriority(w);        % Translate requested speed of the grating (in cycles per second)        % into a shift value in "pixels per frame", assuming given        % waitduration: This is the amount of pixels to shift our "aperture" at        % each redraw:        shiftperframe= pixelspersecond * waitduration;                % wait until the start of the trial        while (GetSecs-trialStartTime < exptdesign.intertrial)            ;        end;        Screen('glPoint',w,black,fixPntX,fixPntY,fixPntSize);        [VBLTimestamp]=Screen('Flip', w);        for kk=1:3   % flicker fixation point for 3 cycle at 10 Hz            Screen('glPoint',w,white,fixPntX,fixPntY,fixPntSize);	% paint white point            while(GetSecs-VBLTimestamp < 0.1)  ;            end;            [VBLTimestamp ]=Screen('Flip', w);            Screen('glPoint',w,black,fixPntX,fixPntY,fixPntSize); % paint black point            while(GetSecs-VBLTimestamp < 0.1)            end;            [VBLTimestamp ]=Screen('Flip', w);        end;        if ( GetSecs-VBLTimestamp > exptdesign.fixPntOffset )            disp('fixation offset error') % record error here        end;        while (GetSecs-VBLTimestamp < exptdesign.fixPntOffset)        end;        vbl = GetSecs;        vblendtime = vbl + curDuration;        i=0;        dir = (round(rand)); % 1 is right, 0 is left.        % Animationloop:        while(vbl < vblendtime)            % Shift the grating by "shiftperframe" pixels per frame:            xoffset = dir*ppc+((-1)^dir)*mod(i*shiftperframe,ppc);            %             xoffset = mod(i*shiftperframe,ppc);            i = i+1;            % Define shifted srcRect that cuts out the properly shifted rectangular            % area from the texture:            srcRect=[xoffset 0 xoffset + visiblesize visiblesize];            % Draw grating texture,:            Screen('DrawTexture', w, GrTexture, srcRect, dstRect, stimparams.angle);            % Draw gaussian mask over grating: We need to subtract 0.5 from            % the real size to avoid interpolation artifacts that are            % created by the gfx-hardware due to internal numerical            % roundoff errors when drawing rotated images:            Screen('DrawTexture', w,   gab_MskTexture, [0 0 visiblesize visiblesize], dstRect, stimparams.angle);            % Flip 'waitframes' monitor refresh intervals after last redraw.            vbl = Screen('Flip', w, vbl + (waitframes - 0.5) * ifi);        end        Screen('FillRect',w, RGBgrey); % fill next buffer with uniform grey        Screen('glPoint',w,black,fixPntX,fixPntY,fixPntSize);        [VBLTimestamp ]=Screen('Flip', w);        if stimparams.angle == 0 % right left            % draw the response window            L(1) = center(1) - TxtSizeDiv2 - 100;            R(1) = center(1) + 100;            L(2) = center(2) - TxtSizeDiv2;            R(2) = center(2) - TxtSizeDiv2;            Screen('DrawText', w, 'R', R(1), R(2),black);            Screen('DrawText', w, 'L', L(1), L(2),black);        elseif stimparams.angle == 90 % up down            % draw the response window            U(2) = center(2) - 100;            D(2) = center(2) - TxtSizeDiv2 + 100;            U(1) = center(1) - TxtSizeDiv2;            D(1) = center(1) - TxtSizeDiv2;            Screen('DrawText', w, 'U', U(1), U(2),black);            Screen('DrawText', w, 'D', D(1), D(2),black);        end%         while (GetSecs-VBLTimestamp < exptdesign.fixPntOffset)%         end;        Screen('glPoint',w,black,fixPntX,fixPntY,fixPntSize);        Screen('Flip', w); % draw response screen        % get response key        theKey=pbGetKey(goodKeys,responseKeyboard);        respLocation = find(goodKeys==theKey);        if (respLocation==escapeLocation)            quitflag=1;            break;        end;        correct=-1;        if (respLocation~=escapeLocation)            correct = (dir==1 && respLocation == 2) || (dir == 0 && respLocation ==1);            screc(scID)=psyfuncUpdate(screc(scID),correct); % update staircase records            if exptdesign.usefeedback==1                if correct                    Snd('Play',corrsnd); % give auditory feedback for correct response                else                    Snd('Play',wrongsnd); % give auditory feedback for incorrect response                end;            end;        data(curtrial, :) = [curContrast  curSFcpd cursizedeg gaussSD dir respLocation scID curDuration correct];        end; % if (response > 0)        Screen('FillRect',w, RGBgrey); % fill next buffer with uniform grey        Screen('glPoint',w,black,fixPntX,fixPntY,fixPntSize); % draw fixation point        Screen('Flip', w); %        tmpdone=1;        for kk=1:numStaircases            if ~psyfuncfinished(screc(kk))                tmpdone=0;                break;            end; % if        end; % for kk      checks all staircases, sets alldone to 1 if all sc are done        alldone=tmpdone;                curtrial=curtrial+1; % increment trial counter        end; % while    if exptdesign.curBlock == exptdesign.numconds    Screen('DrawText', w, 'Thank you for your participation! ', 100,100, black);     Screen('Flip', w); %    end        WaitSecs(5);       Screen('CloseAll');catch    % This "catch" section executes in case of an error in the "try" section    % above.  Importantly, it closes the onscreen window if it's open.    save CenSurr_crash.mat    Screen('CloseAll');    rethrow(lasterror);endreturn;