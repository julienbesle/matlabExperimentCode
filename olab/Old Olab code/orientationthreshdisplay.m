function [data,screc,quitflag]=orEccthreshdisplay(cal,stimpix,displayrate,screc,mainscrs,nzpattern,exptdesign);%% function [data,screc,quitflag]=orientationthreshdisplay(cal,stimpix,displayrate,screc,mainscrs,nzpattern,exptdesign);%MONTE_CARLO_SIM=0;% initialize the random number generatorrandn('state',sum(100*clock));% for playing sounds using 'snd'SND_RATE=8192;% data matrixnc=9+2*exptdesign.numlocs+4*exptdesign.numlocs;data=zeros(1,nc);% These are the values for the response keyskey1 = abs('1'); % face 1key2 = abs('2'); % face 2key3 = abs('9'); % face 3key4 = abs('0'); % face 4escapekey = 27;% This is the value for the space bar, which is used to start each trial.spacebar=32;deletekey=8;% convert stimulus duration from seconds to framesstimframes=round(displayrate*exptdesign.duration);isiframes=round(displayrate*exptdesign.isi);cuedurationframes=round(displayrate*exptdesign.cueduration);cueoffsetframes=round(displayrate*exptdesign.cueoffset);% fixpntoffsetframes=round(displayrate*exptdesign.fixpntstimoffset);% if fixpntoffsetframes<1% 	fixpntoffsetframes=1;% end;% make sounds for feedback, etc.introsnd=makesnd(600,.2,.6,SND_RATE);intervalsnd=makesnd(300,exptdesign.duration,.6,SND_RATE);corrsnd=makesnd(800,.09,.6,SND_RATE);wrongsnd=makesnd(200,.09,.7,SND_RATE);% calculate the max and min contrasts for this displayL = cal.lmaxminave;cmax=(L(1)-L(3))/L(3);cmin=(L(2)-L(3))/L(3);dcLUT=0;	% the rgb value for DC is stored in LUT index 0 (zero-based); for matlab, it is stored in array position #1fixrgb=[0 0 0];	% the RGB value for the fixation pointfixLUT=1;	% the rgb value is stored in LUT index 1 (zero-based); for matlab, it is stored in array position #2wordLUT=2;	% the rgb value for the stimulus word is stored in LUT index 2;% this makes an initial CLUT set to average luminance. In the calibration% routine, average luminance is arbitrarily chosen as the luminance % of the pixel combination [160 160 160]. you can change this easily.tempCLUT=ones(256,3)*160;% this just stuffs a low-luminance value in the clut for text display.% it will be overwritten later on.tempCLUT(2,:)=[1 1 1];% this is the screen upon which the image is to be displayexptdesign. defarg('mainscrs',0);% this opens brainard's screen function. it is a wrapper% around the original function that can set mutiple screens% at once and sets unused screens to zero luminance.[screens,rects] = openscreens(mainscrs,tempCLUT);% this is a wrapper around brainard's functions that allow you% to change the text display attributes in one command.[oldfont,oldsz,oldstyle] = settext(screens(1),'Times',26,1);fixpnt=setrect(0,0,8,8);fixpnt=CenterRect(fixpnt,rects(1,:)); % fixation point rectanglestimrect=setrect(0,0,stimpix,stimpix);for kk=1:exptdesign.numlocs	curAngle=exptdesign.targlocsdeg(kk); % dm: col 1 is target direction; col 2 is random direction increment; col 3 is ISI; col 4 is radius	curRadius=exptdesign.stimeccentricity(kk);	% first, calculate the x,y coordinates	xoffset=round(curRadius*cos(deg2rad(curAngle)));	yoffset=round(curRadius*sin(deg2rad(curAngle)));	% next, build the destination rectangle for each location% 	destrect(kk,:)=setrect(0,0,stimpix,stimpix); % create stimulus rectangle	destrect(kk,:)=CenterRect(stimrect,rects(1,:)); % center it in the display window	destrect(kk,:)=OffsetRect(destrect(kk,:),xoffset,yoffset); % newRect = OffsetRect(oldRect,x,y)	% finally, build the cueing rectangle for each location 	boxrect(kk,:)=setrect(0,0,stimpix+8,stimpix+8); % create rectangle	boxrect(kk,:)=CenterRect(boxrect(kk,:),rects(1,:)); % center it in the display window	boxrect(kk,:)=OffsetRect(boxrect(kk,:),xoffset,yoffset); % newRect = OffsetRect(oldRect,x,y)end;% make rects for response window% resprect=setrect(0,0,64,64);% % int1dest(1,:)=CenterRect(resprect,rects(1,:)); int1dest(1,:)=offsetrect(int1dest(1,:),-128,0);% int2dest(2,:)=CenterRect(resprect,rects(1,:)); int2dest(1,:)=offsetrect(int2dest(1,:),128,0);for kk=1:exptdesign.numlocs	offscrptrs1(kk)=screen(mainscrs,'OpenOffscreenWindow',0,stimrect);	% offscreen window for target; fill with 0, which is clut index for DC	offscrptrs2(kk)=screen(mainscrs,'OpenOffscreenWindow',0,stimrect);	% offscreen window for target; fill with 0, which is clut index for DC	screen(offscrptrs1(kk),'SetDrawingRegion',stimrect,1); % set the drawing region to be a circle; do this because patterns will be circular	screen(offscrptrs2(kk),'SetDrawingRegion',stimrect,1); % set the drawing region to be a circle; do this because patterns will be circularend;% create a clut and load itdefaultCLUT=[0:255]'*[1 1 1];defaultCLUT(1,:)=[160,160,160]; % DC value in index 1defaultCLUT(2,:)=fixrgb; % value for the fixation point & textscreen(screens(1),'SetClut',defaultCLUT,0);screen(screens(1),'FillRect',0); % this fills the screen with clut index 0, which is [160 160 160]% start of the scan...hidecursor; % this hides the mouse cursorstarttime=getsecs;% light adaptadaptpause(screens(1),rects(1,:),exptdesign.adaptseconds);err=snd('Open'); % open the sound buffererr=snd('Play',introsnd,SND_RATE); err=snd('Play',corrsnd,SND_RATE); err=snd('Play',wrongsnd,SND_RATE);flushevents('keyDown'); % this flushes any key presses before this point.flushmouse;waitsecs(1);screen(screens(1),'SetClut',defaultCLUT,0); % load clutscreen(screens(1),'FillRect',0); % clear the screen with average luminancescreen(screens(1),'FillOval',1,fixpnt); % draw fixation pointquitflag=0;alldone=0;curtrial=1;targbasevar=var(nzpattern.target(:));distractAbasevar=var(nzpattern.distractorA(:));distractBbasevar=var(nzpattern.distractorB(:));while ((alldone==0)&(quitflag==0))	stime=getsecs; % get the start time for this trial; we'll use this later	gotone=0;	while (gotone==0)		curlocation=randomcondition(exptdesign.numlocs); % randomly select the location of the target for this trial		condID=randomcondition(exptdesign.numnz); % randomly select the external noise for this trial		if (~psyfuncfinished(screc(curlocation,condID))) gotone=1; end; % check to see if the staircase is still running	end;	stimorder=randomcondition(2); % randomly select a 1 or 2; will use this to select the interval containing the stimulus	nzvar=screc(curlocation,condID).appspec;	% current external noise variance	%create noise fields for each location and each interval	for kk=1:exptdesign.numlocs		[stim1(:,:,kk),noise1(:,kk)]=noise2d(stimpix,nzvar,cmin,cmax,0);		[stim2(:,:,kk),noise2(:,kk)]=noise2d(stimpix,nzvar,cmin,cmax,0);	end;	curStimVariance=psyfuncGetValue(screc(curlocation,condID)); % get the stimulus variance for the current staircase record	tmptarg=nzpattern.target.*sqrt(curStimVariance/targbasevar); % set the target's variance	tmpdistractA=nzpattern.distractorA.*sqrt(curStimVariance/distractAbasevar); % set the distractor's variance	tmpdistractB=nzpattern.distractorB.*sqrt(curStimVariance/distractBbasevar); % set the distractor's variance		% now we have to decide which distractor to place at each location	for kk=1:exptdesign.numlocs		patID1(kk)=randomcondition(2); % randomly select a 1 or 2		patID2(kk)=randomcondition(2); % randomly select a 1 or 2	end;	% indicate location of target by storing zero at correct location/interval	if (stimorder==1)		patID1(curlocation)=0;	elseif (stimorder==2)		patID2(curlocation)=0;	end;					% add the target and distractors to the noise fields	for kk=1:exptdesign.numlocs		% first interval 1		switch patID1(kk)		case 0			stim1(:,:,kk)=stim1(:,:,kk)+tmptarg;	% add target to noise		case 1			stim1(:,:,kk)=stim1(:,:,kk)+tmpdistractA; % add distractor A to noise		case 2			stim1(:,:,kk)=stim1(:,:,kk)+tmpdistractB; % add disctractor B to noise		end;				% then interval 2		switch patID2(kk)		case 0			stim2(:,:,kk)=stim2(:,:,kk)+tmptarg;	% add target to noise		case 1			stim2(:,:,kk)=stim2(:,:,kk)+tmpdistractA; % add distractor A to noise		case 2			stim2(:,:,kk)=stim2(:,:,kk)+tmpdistractB; % add disctractor B to noise		end;	end;	% now pack all of the stimulus arrays into 1 big array	% why are we doing this? because we need to compute one clut for	% each stimulus interval, and the colors in the clut depend on the	% max and min luminance across all patterns in each interval.	% The routine that computes the clut, makeimage, only accepts one	% stimulus array, so we pack everything together, pass the giant arrays	% to make image, and then unpack everything when we're done.	tmpstim1=stim1(:,:,1);	tmpstim2=stim2(:,:,1);	for kk=2:exptdesign.numlocs		tmpstim1=[tmpstim1;stim1(:,:,kk)];		tmpstim2=[tmpstim2;stim2(:,:,kk)];	end;				% this is the routine that makes a pixel image and a CLUT for display.	% the first index in the clut is always reserved for average luminance.	% remember that the routine expects the image in terms of *contrast*.	[currimage1,currclut1]=makeimage(tmpstim1,cal,0); % the value [0,0,0] is stored in clut index 2 (location 1 when addressing the zero-based, 0-255 hardware); we use this colour for the fixation point	[currimage2,currclut2]=makeimage(tmpstim2,cal,0); % the value [0,0,0] is stored in clut index 2 (location 1 when addressing the zero-based, 0-255 hardware); we use this colour for the fixation point	% now unpack the images	for kk=1:exptdesign.numlocs		nr1=1+(kk-1)*stimpix;		nr2=stimpix+(kk-1)*stimpix;		stim1(:,:,kk)=currimage1(nr1:nr2,:);		stim2(:,:,kk)=currimage2(nr1:nr2,:);	end;	%	screen(offscrptrs(1),'PutImage',currimage); % store in offscreen pixel map		% store everything in offscreen pixel maps; remember, drawing will be confined to a circular window within pixel map	for kk=1:exptdesign.numlocs		screen(offscrptrs1(kk),'PutImage',stim1(:,:,kk)); % store in offscreen pixel map		screen(offscrptrs2(kk),'PutImage',stim2(:,:,kk)); % store in offscreen pixel map	end;		gotime=stime+exptdesign.intertrial; % wait here		while (getsecs<gotime) end;	screen(screens(1),'WaitBlanking'); % wait 1 frame	% draw spatial markers in the same colour as the fixation point	for kk=1:exptdesign.numlocs		screen(screens(1),'FrameOval',1,boxrect(kk,:)); % draw a circle at all locations	end;	screen(screens(1),'WaitBlanking',cueoffsetframes-1); % wait for the correct number of frames	% now flicker the cued location	cuetime=getsecs+exptdesign.cueduration;	while (getsecs<cuetime)		screen(screens(1),'WaitBlanking',4); % wait 5 frames		% now erase cues		if (exptdesign.cuedsetsize==exptdesign.numlocs)			for kk=1:exptdesign.numlocs				screen(screens(1),'FrameOval',0,boxrect(kk,:)); % erase circle at all locations			end;		else			screen(screens(1),'FrameOval',0,boxrect(curlocation,:)); % erase circle at only the target location (i.e., cue is 100% valid)		end;		screen(screens(1),'WaitBlanking',4); % wait 5 frames		% re-draw cues		if (exptdesign.cuedsetsize==exptdesign.numlocs)			for kk=1:exptdesign.numlocs				screen(screens(1),'FrameOval',1,boxrect(kk,:)); % draw a circle at all locations			end;		else			screen(screens(1),'FrameOval',1,boxrect(curlocation,:)); % draw a circle at only the target location (i.e., cue is 100% valid)		end;	end; % while	% now erase cues% 	if (exptdesign.cuedsetsize==exptdesign.numlocs)% 		for kk=1:exptdesign.numlocs% 			screen(screens(1),'FrameOval',0,boxrect(kk,:)); % erase circle at all locations% 		end;% 	else% 		screen(screens(1),'FrameOval',0,boxrect(curlocation,:)); % erase circle at only the target location (i.e., cue is 100% valid)% 	end;	screen(screens(1),'WaitBlanking',cueoffsetframes-1); % wait for the correct number of frames	% do interval 1	screen(screens(1),'SetClut',currclut1,0); % write to clut and return 1 frame later	screen(screens(1),'WaitBlanking',cueoffsetframes); % wait 1 framefor kk=1:exptdesign.numlocs	for kk=1:exptdesign.numlocs		screen('CopyWindow',offscrptrs1(kk),screens(1),stimrect,destrect(kk,:)); % copy the images to the screen	end;	% re-draw spatial markers in the same colour as the fixation point	for kk=1:exptdesign.numlocs		screen(screens(1),'FrameOval',1,boxrect(kk,:)); % draw a circle at all locations	end;	err=snd('Play',intervalsnd,SND_RATE);		screen(screens(1),'WaitBlanking',stimframes); % wait for the correct number of frames	for kk=1:exptdesign.numlocs		screen(screens(1),'FillRect',0,destrect(kk,:)); % fill destrects with avg lum	end;	% re-draw spatial markers in the same colour as the fixation point	for kk=1:exptdesign.numlocs		screen(screens(1),'FrameOval',1,boxrect(kk,:)); % draw a circle at all locations	end;	% wait for duration of ISI	screen(screens(1),'WaitBlanking',isiframes); % wait for the correct number of frames	% do interval 2	screen(screens(1),'SetClut',currclut2,0); % write to clut and return 1 frame later	for kk=1:exptdesign.numlocs		screen('CopyWindow',offscrptrs2(kk),screens(1),stimrect,destrect(kk,:)); % copy the images to the screen	end;		% re-draw spatial markers in the same colour as the fixation point	for kk=1:exptdesign.numlocs		screen(screens(1),'FrameOval',1,boxrect(kk,:)); % draw a circle at all locations	end;	err=snd('Play',intervalsnd,SND_RATE);	screen(screens(1),'WaitBlanking',stimframes); % wait for the correct number of frames	for kk=1:exptdesign.numlocs		screen(screens(1),'FillRect',0,destrect(kk,:)); % fill destrects with avg lum	end;	% re-draw spatial markers in the same colour as the fixation point	for kk=1:exptdesign.numlocs		screen(screens(1),'FrameOval',1,boxrect(kk,:)); % draw a circle at all locations	end;	stimofftime=getsecs;	% now erase cues	screen(screens(1),'WaitBlanking',cueoffsetframes-1); % wait for the correct number of frames	for kk=1:exptdesign.numlocs		screen(screens(1),'FrameOval',0,boxrect(kk,:)); % erase circle at all locations	end;	screen(screens(1),'WaitBlanking'); % wait 1 frame	screen(screens(1),'SetClut',defaultCLUT,0);	% get response	if (curtrial==1)		% prompt observer for a response 		waitsecs(exptdesign.isi);		[newx,newy] = centertext(screens(1),rects(1,:),'Interval 1=>"1"       Interval 2=>"2"');	end;	% wait for a kepress to put the next image up. if the escape key is hit	% it will break from the program.	flushevents('keyDown');	resp = 'g';	while abs(resp)~= key1 & abs(resp)~=key2 & ~isquitkey(resp)		resp = getchar;	end	switch abs(resp)	case key1		response=1;	case key2		response=2;	case escapekey		quitflag=1;		break;	end;	rlatency=getsecs-stimofftime;			screen(screens(1),'WaitBlanking'); % wait 1 frame	screen(screens(1),'FillRect',0); % this fills the screen with clut index 0, which is DC.	screen(screens(1),'FillOval',1,fixpnt); % draw fixation point	correct=-1;	if (response > 0)		correct=(response==stimorder);		screc(curlocation,condID)=psyfuncUpdate(screc(curlocation,condID),correct); % update the constant stimuli data structure		if correct			% sound(corrsnd);			err=snd('Play',corrsnd,SND_RATE);		else			% sound(wrongsnd);			err=snd('Play',wrongsnd,SND_RATE);		end;	end; % if (response > 0) & (condID>0)	display([num2str(condID) ', ' num2str(curlocation) ', ' num2str(curStimVariance)]);	if (response>0)		st=size(noise1);		nz1tmp=reshape(noise1,1,st(1)*st(2));		st=size(noise2);		nz2tmp=reshape(noise2,1,st(1)*st(2));		st=size(patID1);		pid1tmp=reshape(patID1,1,st(1)*st(2));		st=size(patID2);		pid2tmp=reshape(patID2,1,st(1)*st(2));		 		data(curtrial,:)=[curtrial,curlocation,condID,nzvar,curStimVariance,stimorder,response,correct,rlatency,pid1tmp,pid2tmp,nz1tmp,nz2tmp]; % update data matrix		curtrial=curtrial+1; % increment trial counter	end; % if (response > 0)		% END OF TRIAL...	tmpdone=1;	for jj=1:exptdesign.numlocs		for kk=1:exptdesign.numnz			if ~psyfuncfinished(screc(jj,kk))				tmpdone=0;				break;			end; % if		end; % for kk	end; % for jj	alldone=tmpdone;	% take a break?	if (curtrial==exptdesign.takebreaktrial)		takebreak(screens(1),rects(1,:));		end;		end; % while ((alldone==0)&(quitflag==0))err=snd('Close'); % close the sound buffer hereshowcursor(0);closeall;	% close the screen and data file. this is a wrapper around brainard that closes % all of the active windows and any text data file that may have been% opened but not closed during the routine.% sound(introsnd);return;