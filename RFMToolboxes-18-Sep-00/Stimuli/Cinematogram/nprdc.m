function displist = nprdc( reel, radiusP, varargin )% NPRDC  Make a Newsome-Pare random dot cinematogram%% displist = nprdc( reel, radiusP, spec1, ... )%     - <reel> is movie to draw RDC into%     - <radiusP> is aperture radius in pixels% early 97  -- created (RFM)% 14-Nov-99 -- distribution parameters changed;  displacement list returned (RFM)D=size(varargin,2);  % number of dot distributionsF=reel.nframes-1;    % number of movie frameswrite=(nargin==0);% get initial dot positions (uses varargin{1}'s RNG for all distributions)totaldots=0;for d=1:D,	totaldots=totaldots+varargin{d}.ndots;endif isfield(varargin{1},'posrng'),	rng=varargin{1}.posrng;else	rng='rngcirc';endinitpos=feval(rng,totaldots,radiusP);initi=0;% get position list for each dot distributiondrawlist=[];displist=[];for d=1:D,	% draw dots to offscreen window	if write,		dotRect = [ 0 0 size(varargin{d}.signaldot) ];		varargin{d}.signalID=screen(reel.destID,'OpenOffscreenWindow',0,dotRect);		screen(varargin{d}.signalID,'PutImage',varargin{d}.signaldot,dotRect);		dotRect = [ 0 0 size(varargin{d}.noisedot) ];		varargin{d}.noiseID=screen(reel.destID,'OpenOffscreenWindow',0,dotRect);		screen(varargin{d}.noiseID,'PutImage',varargin{d}.noisedot,dotRect);	else		varargin{d}.signalID=0;		varargin{d}.noiseID=0;	end	dist=varargin{d};	displistd=[];	if dist.ndots~=0,		% number of coherently moving dots		coherentf=[ ones(dist.signaln,1) ; zeros(dist.ndots-dist.signaln,1) ];				% set initial positions		pos=[];		pos(:,1:2,1)=initpos(initi+1:initi+dist.ndots,:);		initi=initi+dist.ndots;		coherentv=coherentf(randperm(dist.ndots));		pos(find(coherentv==1),3,1)=dist.signalID;		pos(find(coherentv~=1),3,1)=dist.noiseID;		% wrap around		r=sqrt((pos(:,1,1).^2)+(pos(:,2,1).^2));		theta=atan2(-pos(:,2,1),pos(:,1,1));		outside=find(r>radiusP);		if ~isempty(outside),			pos(outside,1,1)=round((2*radiusP-r(outside)).*cos(theta(outside)+pi));			pos(outside,2,1)=round((2*radiusP-r(outside)).*-(sin(theta(outside)+pi)));		end		% positions on successive frames		disp=zeros(dist.ndots,2);		prevcoherentv=coherentv;		for f=2:F,			% get displacements on this frame			disp(find(prevcoherentv==1),:) = ones(dist.signaln,1)*dist.signalstep;			theta=unifrnd(-pi,pi,dist.ndots-dist.signaln,1);			disp(find(prevcoherentv==0),:) = round( dist.noisestep*[ cos(theta) sin(theta) ] );			displistf=[ repmat(d,dist.ndots,1) repmat(f-1,dist.ndots,1) prevcoherentv pos(:,1:2,f-1) disp ];						% add displacements into position matrix			pos(:,1:2,f)=pos(:,1:2,f-1)+disp;			% wrap around			r=sqrt((pos(:,1,f).^2)+(pos(:,2,f).^2));			theta=atan2(-pos(:,2,f),pos(:,1,f));			outside=find(r>radiusP);			if ~isempty(outside),				pos(outside,1,f)=round((2*radiusP-r(outside)).*cos(theta(outside)+pi));				pos(outside,2,f)=round((2*radiusP-r(outside)).*-(sin(theta(outside)+pi)));				displistf(outside,6:7)=NaN;			end			displistd=[ displistd ; displistf ];						% choose new coherently moving dots			if f<F,				coherentv=coherentf(randperm(dist.ndots));			else				coherentv=zeros(dist.ndots,1);			end			% set dot handles			signalv=( coherentv | prevcoherentv ); 			pos(find(signalv==1),3,f)=dist.signalID;			pos(find(signalv~=1),3,f)=dist.noiseID;			prevcoherentv=coherentv;		end			% centre dots		dotSize=size(dist.signaldot);		delx=floor((dotSize(2)-1)/2);		dely=floor((dotSize(1)-1)/2);		pos(:,1,:)=pos(:,1,:)-delx;		pos(:,2,:)=pos(:,2,:)-dely;		displistd(:,4)=displistd(:,4)-delx;		displistd(:,5)=displistd(:,5)-dely;		% append to list			drawlist = cat(1,drawlist,pos);		displist=[ displist ; displistd ];		endend% centre aperture in movie framedelx=round(reel.framesize(1)/2);dely=round(reel.framesize(2)/2);drawlist(:,1,:)=drawlist(:,1,:)+delx;drawlist(:,2,:)=drawlist(:,2,:)+dely;% randomize drawing orderdrawlist=drawlist(randperm(size(drawlist,1)),:,:);% write dots to movie framesif write,		% clear movie frames	for f=1:F,		cls(reel.frameID(f));	%	screen(reel.frameID(f),'FrameRect',255,reel.view);	%	screen(reel.frameID(f),'FrameOval',255,centrerect(reel.view,radiusP*[ 0 0 2 2 ]));	end	% draw RDC into movie frames	embed(reel.frameID(1:F),drawlist);	% free offscreen dot windows	for d=1:D,		screen(varargin{d}.signalID,'Close');		screen(varargin{d}.noiseID,'Close');	endendreturnfunction rndmat = rngcirc( nvect, radiusP )r=radiusP*sqrt(rand(nvect,1))*ones(1,2);theta=unifrnd(-pi,pi,nvect,1);rndmat=round(r.*[ cos(theta) -sin(theta) ]);return