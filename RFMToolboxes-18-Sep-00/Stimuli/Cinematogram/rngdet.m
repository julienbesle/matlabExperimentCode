function rndmat = rngdet( nvect, frames, params )% RNGDET  Generate matrix of deterministic displacements% decode parametersdispSize=params(1);angleMean=deg2rad(params(2));% calculate step required in continuous coordinatesrealStep = dispSize*[ cos(angleMean) -sin(angleMean) ];% determine four closest steps in discrete coordinatesdiscStep(1,:) = [ floor(realStep(1)) floor(realStep(2)) ];discStep(2,:) = [ floor(realStep(1)) ceil(realStep(2))  ];discStep(3,:) = [ ceil(realStep(1))  floor(realStep(2)) ];discStep(4,:) = [ ceil(realStep(1))  ceil(realStep(2))  ];% determine angle of discrete stepsdiscStep(:,3) = rmod(atan2( -discStep(:,2), discStep(:,1) ));% use step matching required angle exactly, if one existsexact=find(discStep(:,3)==angleMean);if ~isempty(exact),	lowStep=discStep(exact(1),:);	highStep=lowStep;	highProp=0;% otherwise, mix steps to give required angle as mean% ( will this break down when meanAngle is near 180 degrees? )else	% determine steps with closest angles greater and less than requested angle	lowSteps = discStep(find(discStep(:,3)<angleMean),:);	[ v i ] = max(lowSteps(:,3));	lowStep  = lowSteps(i,:);	highSteps = discStep(find(discStep(:,3)>angleMean),:);	[ v i ] = min(highSteps(:,3));	highStep  = highSteps(i,:);	% to be fixed:  check difference in discrete and continuous vector sizes	% determine proportion of each step required	highProp = (angleMean-lowStep(1,3))/(highStep(1,3)-lowStep(1,3));	% to be fixed:  weight by size of each stepend% write steps into each framehighNum = round(nvect*highProp);high=[ ones(highNum,1) ; zeros(nvect-highNum,1) ];for i=1:frames,	high=high(randperm(nvect));	rndmat(:,:,i)=(high*highStep(1:2))+((1-high)*lowStep(1:2));end%mv=mean(rndmat(:,:,1));%fprintf(1,'RNGDET   %5.2f  ( %5.2f, %5.2f )  %5.2f\n',rad2deg(angleMean),mv(1),mv(2),rad2deg(atan2(-mv(2),mv(1))));returnfunction thetamod = rmod( theta )	thetamod=mod(theta+pi/2,2*pi)-pi/2;return