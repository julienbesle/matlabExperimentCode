function nprdc( reel, dim, varargin )% NPRDC  Make a Newsome-Pare random dot cinematogram%% nprdc( reel, dim, spec1, ... )%     - <reel> is movie to draw RDC into%     - <dim> is dimension of position grid [ X Y ]% early 97 -- created (RFM)X=dim(1);Y=dim(2);D=size(varargin,2);F=reel.nframes;% calculate border that will center RDC in movie framexborder=round((reel.framesize(1)-X)/2);yborder=round((reel.framesize(2)-Y)/2);% get initial dot positionstotaldots=0;for d=1:D,	totaldots=totaldots+varargin{d}.ndots;endrng=eval('varargin{1}.posrng','''rnginit''');initpos=feval(rng,totaldots,[ X Y ]);initi=0;% get position list for each distributiondrawlist=[];for d=1:D,	% draw dots to offscreen window	dotRect = [ 0 0 size(varargin{d}.signaldot) ];	varargin{d}.signalID=screen(reel.destID,'OpenOffscreenWindow',0,dotRect);	screen(varargin{d}.signalID,'PutImage',varargin{d}.signaldot,dotRect);	dotRect = [ 0 0 size(varargin{d}.noisedot) ];	varargin{d}.noiseID=screen(reel.destID,'OpenOffscreenWindow',0,dotRect);	screen(varargin{d}.noiseID,'PutImage',varargin{d}.noisedot,dotRect);		dist=varargin{d};	if dist.ndots~=0,		% get step size and coherence		xstep=dist.params(1);		ystep=dist.params(2);		stepsize=vectsize([ xstep ystep ]);		coherence=max(min(dist.params(3),1),0);		coherentn=round(coherence*dist.ndots);		coherentf=[ ones(coherentn,1) ; zeros(dist.ndots-coherentn,1) ];				% set initial positions		pos=[];%		pos(:,1:2,1) = feval('rnginit',dist.ndots,[ X Y ]);pos(:,1:2,1)=initpos(initi+1:initi+dist.ndots,:);initi=initi+dist.ndots;		coherentv=coherentf(randperm(dist.ndots));		pos(:,3,1)=(coherentv*dist.signalID) + ((1-coherentv)*dist.noiseID);				disp=zeros(dist.ndots,2);		prevcoherentv=coherentv;		for f=2:F,			% get displacements			disp(find(prevcoherentv==1),:) = ones(coherentn,1)*[ xstep ystep ];			theta=unifrnd(-pi,pi,dist.ndots-coherentn,1);			disp(find(prevcoherentv==0),:) = round( stepsize*[ cos(theta) sin(theta) ] );			% add displacements into position matrix			pos(:,1:2,f)=pos(:,1:2,f-1)+disp;			% set dot types			if f<F,				coherentv=coherentf(randperm(dist.ndots));			else				coherentv=zeros(dist.ndots,1);			end			% set dot handles			signalv=( coherentv | prevcoherentv ); 			pos(:,3,f)=(signalv*dist.signalID) + ((1-signalv)*dist.noiseID);			prevcoherentv=coherentv;		end		% wrap, create border, and centre dot		dotSize=size(dist.signaldot);		delx=floor((dotSize(2)-1)/2);		dely=floor((dotSize(1)-1)/2);		pos(:,1,:)=pmod(pos(:,1,:),X)+xborder-delx;		pos(:,2,:)=pmod(pos(:,2,:),Y)+yborder-dely;		% append to list			drawlist = cat(1,drawlist,pos);		endend% randomize drawing orderdrawlist = drawlist(randperm(size(drawlist,1)),:,:);% clear movie framesfor f=1:reel.nframes,	cls(reel.frameID(f));end% draw RDC into movie framesembed(reel.frameID,drawlist);% free dot windowsfor d=1:D,	screen(varargin{d}.signalID,'Close');	screen(varargin{d}.noiseID,'Close');endreturn