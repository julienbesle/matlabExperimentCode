function nprdc( reel, radius, varargin )% NPRDC  Make a Newsome-Pare random dot cinematogram%% nprdc( reel, radius, spec1, ... )%     - <reel> is movie to draw RDC into%     - <radius> is aperture radius in pixels% early 97 -- created (RFM)D=size(varargin,2);  % number of dot distributionsF=reel.nframes;      % number of movie frames% get initial dot positionstotaldots=0;for d=1:D,	totaldots=totaldots+varargin{d}.ndots;endrng=eval('varargin{1}.posrng','''rngcirc''');initpos=feval(rng,totaldots,[ 2*radius 2*radius ])-radius;initi=0;% get position list for each dot distributiondrawlist=[];for d=1:D,	% draw dots to offscreen window	dotRect = [ 0 0 size(varargin{d}.signaldot) ];	varargin{d}.signalID=screen(reel.destID,'OpenOffscreenWindow',0,dotRect);	screen(varargin{d}.signalID,'PutImage',varargin{d}.signaldot,dotRect);	dotRect = [ 0 0 size(varargin{d}.noisedot) ];	varargin{d}.noiseID=screen(reel.destID,'OpenOffscreenWindow',0,dotRect);	screen(varargin{d}.noiseID,'PutImage',varargin{d}.noisedot,dotRect);		dist=varargin{d};	if dist.ndots~=0,		% coherent dot step		xstep=dist.params(1);		ystep=dist.params(2);		stepsize=vectsize([ xstep ystep ]);				% number of coherently moving dots		coherentn=dist.params(3);		coherentf=[ ones(coherentn,1) ; zeros(dist.ndots-coherentn,1) ];				% initial positions		pos=[];		pos(:,1:2,1)=initpos(initi+1:initi+dist.ndots,:);		initi=initi+dist.ndots;		coherentv=coherentf(randperm(dist.ndots));		pos(find(coherentv==1),3,1)=dist.signalID;		pos(find(coherentv~=1),3,1)=dist.noiseID;		% wrap around		r=sqrt((pos(:,1,1).^2)+(pos(:,2,1).^2));		theta=atan2(-pos(:,2,1),pos(:,1,1));		outside=find(r>radius);		if ~isempty(outside),			pos(outside,1,1)=round((2*radius-r(outside)).*cos(theta(outside)+pi));			pos(outside,2,1)=round((2*radius-r(outside)).*-(sin(theta(outside)+pi)));		end					% positions on successive frames		disp=zeros(dist.ndots,2);		prevcoherentv=coherentv;		for f=2:F,			% get displacements on this frame			disp(find(prevcoherentv==1),:) = ones(coherentn,1)*[ xstep ystep ];if 1,			theta=unifrnd(-pi,pi,dist.ndots-coherentn,1);elseincoherentn=dist.ndots-coherentn;theta=2*pi*(0:(incoherentn-1))/incoherentn;theta=theta(randperm(incoherentn))';end			disp(find(prevcoherentv==0),:) = round( stepsize*[ cos(theta) sin(theta) ] );			% add displacements into position matrix			pos(:,1:2,f)=pos(:,1:2,f-1)+disp;			% wrap around			r=sqrt((pos(:,1,f).^2)+(pos(:,2,f).^2));			theta=atan2(-pos(:,2,f),pos(:,1,f));			outside=find(r>radius);			if ~isempty(outside),				pos(outside,1,f)=round((2*radius-r(outside)).*cos(theta(outside)+pi));				pos(outside,2,f)=round((2*radius-r(outside)).*-(sin(theta(outside)+pi)));			end						% set dot types			if f<F,				coherentv=coherentf(randperm(dist.ndots));			else				coherentv=zeros(dist.ndots,1);			end			% set dot handles			signalv=( coherentv | prevcoherentv ); 			pos(find(signalv==1),3,f)=dist.signalID;			pos(find(signalv~=1),3,f)=dist.noiseID;			prevcoherentv=coherentv;		end		% centre dot		dotSize=size(dist.signaldot);		delx=floor((dotSize(2)-1)/2);		dely=floor((dotSize(1)-1)/2);		pos(:,1,:)=pos(:,1,:)-delx;		pos(:,2,:)=pos(:,2,:)-dely;		% append to list			drawlist = cat(1,drawlist,pos);		endend% centre aperture in movie framedelx=round(reel.framesize(1)/2);dely=round(reel.framesize(2)/2);drawlist(:,1,:)=drawlist(:,1,:)+delx;drawlist(:,2,:)=drawlist(:,2,:)+dely;% randomize drawing orderdrawlist=drawlist(randperm(size(drawlist,1)),:,:);% clear movie framesfor f=1:reel.nframes,	cls(reel.frameID(f));end% draw RDC into movie framesembed(reel.frameID,drawlist);% free dot windowsfor d=1:D,	screen(varargin{d}.signalID,'Close');	screen(varargin{d}.noiseID,'Close');endreturn