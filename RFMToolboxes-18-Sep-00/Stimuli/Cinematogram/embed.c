/*embed.c -- draw stimuli in windows using QuickDrawMATLAB usage:  embed( frameID, drawlist )23/01/98 -- created (RFM)*/#include <stdlib.h>#include <string.h>#include <math.h>#include "mex.h"#include "Quickdraw.h"#include "matdef.h"#include "zmex.h"#define max( x , y ) ( ((x)>(y)) ? (x) : (y) )#define winpixmap( window ) (((CGrafPtr)window)->portPixMap)void embed(const mxArray *pFrameIDArr,const mxArray *pDrawListArr,const char *pszMode);void maxcopybits(WindowPtr srcWin,Rect srcRect,WindowPtr dstWin,Rect dstRect);/* gateway function */void mexFunction(int nlhs,mxArray *plhs[],int nrhs,const mxArray *prhs[]) {//	if(nrhs<3)		embed(prhs[0],prhs[1],"srcCopy");//	else//		embed(prhs[0],prhs[1],zxGetString(prhs[2]));	return;	}/* main routine */void embed(const mxArray *pFrameIDArr,const mxArray *pDrawListArr,const char *pszMode) {	int i,j,f,d;	char szStr[81];	WindowPtr srcWin, dstWin;	Rect srcRect, dstRect;	RGBColor rFg,rBk;	Mat2D rBkMat;	int nMax=strcmp(pszMode,"max");	/* list of windows to draw into */	double *pFrameIDMat = mxGetPr(pFrameIDArr);	int F=mxGetM(pFrameIDArr)*mxGetN(pFrameIDArr);	/* list of dots to draw */	int nDots=*(mxGetDimensions(pDrawListArr));	Mat3D rDrawMat;	WRAP3D( rDrawMat, pDrawListArr, nDots, 3, F );/*GetForeColor(&rFg);sprintf(szStr,"fg:  %ld %ld %ld\n",rFg.red,rFg.green,rFg.blue);mexPrintf(szStr);GetForeColor(&rBk);sprintf(szStr,"bk:  %ld %ld %ld\n",rBk.red,rBk.green,rBk.blue);mexPrintf(szStr);*/	/* set background colour *//*	WRAP2D( rBkMat, pBkArr );	rBk.red=  GET2D( rBkMat, 0, 0 );	rBk.green=GET2D( rBkMat, 0, 1 );	rBk.blue= GET2D( rBkMat, 0, 2 );	RGBBackColor(&rBk);*/		/* draw into each window in turn */	for(f=0;f<F;f++) {		dstWin=(WindowPtr)(long)*(pFrameIDMat+f);		for(d=0;d<nDots;d++) {			/* get drawing position and dot window */			i=(int)GET3D( rDrawMat, d, 0, f );			j=(int)GET3D( rDrawMat, d, 1, f );			srcWin=(WindowPtr)(long)GET3D( rDrawMat, d, 2, f );			if(srcWin!=NULL) {				/* get source and destination rectangles */				srcRect=srcWin->portRect;				dstRect=srcRect;				OffsetRect(&dstRect,i,j);						/* copy dot into window */				if(nMax==0)					maxcopybits(srcWin,srcRect,dstWin,dstRect);				else					CopyBits( *(BitMapHandle)winpixmap( srcWin ), 					          *(BitMapHandle)winpixmap( dstWin ),							  &srcRect, &dstRect, srcCopy+transparent,							  dstWin->clipRgn );						  			}		}	}		return;}void maxcopybits(WindowPtr srcWin,Rect srcRect,WindowPtr dstWin,Rect dstRect) {	int i,j,M,N,nSrcRow,nDstRow;	unsigned int nSrc,nDst;	BitMap *pSrcBits=*(BitMapHandle)(((CGrafPtr)srcWin)->portPixMap),		*pDstBits=*(BitMapHandle)(((CGrafPtr)dstWin)->portPixMap);	RGBColor *pPixels;	GrafPtr oldPort;/*	GetPort(&oldPort);	M=(srcRect.bottom-srcRect.top);	N=(srcRect.right-srcRect.left);	pPixels=(RGBColor*)mxCalloc(M*N,sizeof(RGBColor));	SetPort((GrafPtr)srcWin);	for(i=0;i<M;i++)		for(j=0;j<N;j++)			GetCPixel(srcRect.left+j,srcRect.top+i,pPixels+N*i+j);	SetPort((GrafPtr)dstWin);	for(i=0;i<M;i++)		for(j=0;j<N;j++)			SetCPixel(dstRect.left+j,dstRect.top+i,pPixels+N*i+j);	SetPort(oldPort);	mxFree(pPixels); */	nSrcRow=(pSrcBits->rowBytes)&0x0FFF;	nDstRow=(pDstBits->rowBytes)&0x0FFF;	M=(srcRect.bottom-srcRect.top);	N=(srcRect.right-srcRect.left);	for(i=0;i<M;i++)		for(j=0;j<N;j++)			if((dstRect.left+j<dstRect.right)&(dstRect.top+i<dstRect.bottom)) {				nSrc=*((pSrcBits->baseAddr)+(nSrcRow*(i+srcRect.top))+(j+srcRect.left));				nDst=*((pDstBits->baseAddr)+(nDstRow*(i+dstRect.top))+(j+dstRect.left));				*((pDstBits->baseAddr)+(nDstRow*(i+dstRect.top))+(j+dstRect.left))=max(nSrc,nDst);			}			else				zxPrintf("bad write to %d,%d\n",i,j);	return;}