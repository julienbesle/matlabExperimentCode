function [data,screc,params,quitflag]=CenSurrDisplay(sessinfo, scrinfo, muselsl, exptdesign, params, museflags, screc)% unravel structures to raw varstmp = fields(sessinfo);for ii=1:length(tmp)    eval([tmp{ii},'=sessinfo.',tmp{ii},';']);endtmp = fields(scrinfo);for ii=1:length(tmp)    eval([tmp{ii},'=scrinfo.',tmp{ii},';']);endwindow=w;% if eegConnect>0%     tmp = fields(muselsl);%     for ii=1:length(tmp)%         eval([tmp{ii},'=muselsl.',tmp{ii},';']);%     end% endtmp = fields(exptdesign);for ii=1:length(tmp)    eval([tmp{ii},'=exptdesign.',tmp{ii},';']);endleftKey = exptdesign.rspkeys.left;rightKey = exptdesign.rspkeys.right;upKey = exptdesign.rspkeys.midleft;downKey = exptdesign.rspkeys.midright;spaceKey = exptdesign.rspkeys.space;escapeKey = exptdesign.rspkeys.escape;switch params.motionDirection    case 'UpDown'        responseKeys = [upKey downKey];        fprintf('Response keys are %s for up, %s for down', KbName(responseKeys(1)), KbName(responseKeys(2)))    case 'LeftRight'        responseKeys = [leftKey rightKey];        fprintf('Response keys are %s for up, %s for down', KbName(responseKeys(1)), KbName(responseKeys(2)))endtry    DEBUG=0;        % make sounds for feedback, etc.    %    SND_RATE=8192;    %    corrsnd=makesnd(700,.3,.7,SND_RATE);    %    wrongsnd=makesnd(200,.3,.6,SND_RATE);        %% make feedback sounds    % set up sound channel for feedback    pahandle = PsychPortAudio('Open', exptdesign.audio.device, 1, 1, exptdesign.audio.samplerate, exptdesign.audio.nchannels); % open 1 channel    oldVolume = PsychPortAudio('Volume',pahandle,exptdesign.audio.fdbkVolume);        corrsnd = MakeBeep(exptdesign.audio.fdbkCorHz, exptdesign.audio.fdbkDur, exptdesign.audio.samplerate);    wrongsnd = MakeBeep(exptdesign.audio.fdbkIncHz, exptdesign.audio.fdbkDur, exptdesign.audio.samplerate);        if exptdesign.audio.nchannels==2        corrsnd = [corrsnd; corrsnd];        wrongsnd = [wrongsnd; wrongsnd];    end        waitframes = 1;    waitduration = waitframes * scrinfo.ifi;            % wait for a keypress    if(DEBUG==0) && params.curBlock>1        mytext=['Please press any key when you are ready to resume...'];        [newx, newy, bbox] = DrawFormattedText(w, mytext, 'center', 'center', 0);        Screen('Flip',w);        FlushEvents('keyDown');        KbWait;        Screen('FillRect',w, grey);        Screen('Flip', w); % flip the buffer to the screen    end            %%  SET UP FOR THIS CONDITION / BLOCK    curSFcpd = params.stimulus.sfcpd ; %stimparams.sfcpd(exptdesign.curBlock);    curSFcpp = params.stimulus.sfcpp;    ppc = (1/curSFcpp); %pixels per cycle        % note that params.stimulus.contrast/sizedeg/gaussSD are already sorted    % to a random order in CenSurrMuse, so going through them in serial order is good.    curContrast = params.stimulus.contrast(params.curBlock);  %stimparams.contrast(exptdesign.curBlock);    cursizedeg = params.stimulus.sizedeg(params.curBlock);    curGaussSD = params.stimulus.gaussSD(params.curBlock);        %%    % load constants used in expt.    numStaircases = length(screc); % number of staircases        gratingsize =  scrinfo.width*0.9;    texsize = floor(gratingsize/2);        visiblesize = 2*texsize+1;    pixelspersecond = params.stimulus.speedpps;    % initialize data vector    data=[];        % Definition of the drawn rectangle on the screen:    dstRect=[0 0 visiblesize visiblesize];    dstRect=CenterRect(dstRect, wrect);        % Create one single static grating image:    [gr_x]=meshgrid(-texsize:texsize + ceil(ppc), 1);  % 1D row of grating    cgrating = curContrast*cos(2*pi*curSFcpp*gr_x-rand*pi);        % With Bit Stealing    % convert from contrast to luminance:    cgratingLum=avgLum*(1+cgrating);    % convert Luminance to BitStealing Numbers:    cgratingBSnumbers=pbLum2BS(cgratingLum,L,B);    % finally, convert BS numbers to RGB values:    theGrating = pbBitStealing2RGB(cgratingBSnumbers,rgbMat,0);        % Store grating in texture:    GrTexture=Screen('MakeTexture', w, theGrating);            % Make Gaussian Window Mask        gray_layerLUM=avgLum*ones(2*texsize+1, 2*texsize+1);    [x,y]=meshgrid(-texsize:texsize,-texsize:texsize);        % convert Luminance to BitStealing Numbers:    gray_layerBS =pbLum2BS(gray_layerLUM,L,B);    % finally, convert BS numbers to RGB values:    gray_layerRGB = pbBitStealing2RGB(gray_layerBS,rgbMat,0);        transp_layer= (1-exp(-( (x.^2+y.^2) / (2*(curGaussSD^2)) ) ) ) ;  % white: 100% opaque,  black: 100% transparent    %        trim = transp_layer>0.001;    %        trim_transp_layer = trim.*transp_layer;    %    %        transp_layerLUM = scrinfo.maxLum*transp_layer;    %        transp_layerBS =pbLum2BS( transp_layerLUM,L,B);    %             % finally, convert BS numbers to RGB values:    %        transp_layerRGB = pbBitStealing2RGB( transp_layerBS,rgbMat,0);        %        Screen('CloseAll');    %        ListenChar(2);    %        keyboard        %       gab_maskRGBA = zeros([size(gray_layerRGB,1), size(gray_layerRGB,2),4]);    gab_maskRGBA(:,:,1:3) = gray_layerRGB;    gab_maskRGBA(:,:,4) = transp_layer.*scrinfo.white;    gab_MskTexture=Screen('MakeTexture',w,gab_maskRGBA);  % mask texture            %% Show Instructions    if params.curBlock == 1                mytext = ['In this experiment, you will see a brief stimulus on every trial.',...            '\nIt will drift either to the Right or to the Left.', ...            '\nPlease press the right button if it drifted to the Right and left button if it drifted to the Left.', ...            '\nBe as accurate as possible and remember to keep your eyes on the fixation point.',...            '\nYou will hear a high or low-pitched beep for correct and incorrect responses, respectively.',...            '\nPress any button to continue to some practice trials.'];        DrawFormattedText(w,mytext, aes.align, 'center', 0, aes.txtwrapsize, [],[],aes.txtspacing);        Screen('Flip', w);        FlushEvents('keyDown');        WaitSecs(0.5)        KbWait()    else        mytext = ['You have completed ',num2str(params.curBlock-1), ' out of ', num2str(params.numconds), ' block(s) now.',...            '\nIn the next block, the task will remain the same, but the stimulus will be slightly different.',...            '\nRemember, the stimulus will drift either to the Right or to the Left.', ...            '\nPlease press the right button if it drifted to the Right and left button if it drifted to the Left.', ...            '\nYou will hear a high or low-pitched beep for correct and incorrect responses, respectively.',...            '\nBe as accurate as possible and remember to keep your eyes on the fixation point.',...            '\nPress any button to continue with the new stimulus.'];        DrawFormattedText(w,mytext, aes.align, 'center', 0, aes.txtwrapsize, [],[],aes.txtspacing);        Screen('Flip', w);        FlushEvents('keyDown');        WaitSecs(0.5)        KbWait()    end        Screen('FillRect',w, grey);    Screen('DrawTexture', w, exptdesign.fixationBlack);    Screen('Flip', w); % flip the buffer to the screen        TxtSizeDiv2 = aes.txtsize/2;        % %% Do practice trials        quitflag=0;    practicetrial = 1;        if params.curBlock == 1        params.practice.numtrials = 4;    else        params.practice.numtrials = 0;    end        %Initialize Dependent Variable    curDuration=  params.practice.duration;    ABORTEDDATA=0;            PRcontrast = max(params.stimulus.contrast);    while ((practicetrial<= params.practice.numtrials)&&(quitflag==0))                trialStartTime=GetSecs; % mark the start of the trial%                        PRgr_x=meshgrid(-texsize:texsize + ceil(ppc), 1);  % 1D row of grating        PRcgrating = PRcontrast*cos(2*pi*curSFcpp*PRgr_x-rand*pi);                % With Bit Stealing        % convert from contrast to luminance:        PRcgratingLum=avgLum*(1+PRcgrating);        % convert Luminance to BitStealing Numbers:        PRcgratingBSnumbers=pbLum2BS(PRcgratingLum,L,B);        % finally, convert BS numbers to RGB values:        PRtheGrating = pbBitStealing2RGB(PRcgratingBSnumbers,rgbMat,0);                % Store grating in texture:        PRGrTexture=Screen('MakeTexture', w, PRtheGrating);                % Translate requested speed of the grating (in cycles per second)        % into a shift value in "pixels per frame", assuming given        % waitduration: This is the amount of pixels to shift our "aperture" at        % each redraw:        shiftperframe= pixelspersecond * waitduration;                % wait until the start of the trial        while (GetSecs-trialStartTime < params.timing.intertrial)        end                Screen('DrawTexture', w, exptdesign.fixationBlack);        DrawFormattedText(w,'PRACTICE TRIAL',[],[],exptdesign.fixation.colour2);        [VBLTimestamp]=Screen('Flip', w);                switch exptdesign.trialStartMode                        case 'flicker'                                % flicker fixation + for 2 cycles at 20 hz                flickerstart = VBLTimestamp+0.08;                for kk = 1:exptdesign.fixation.numflick                    Screen('DrawTexture', w, exptdesign.fixationWhite);                    DrawFormattedText(w,'PRACTICE TRIAL',[],[],exptdesign.fixation.colour2);                    [VBLTimestamp]=Screen('Flip', window, VBLTimestamp+0.08);                    Screen('DrawTexture', w, exptdesign.fixationBlack);                    DrawFormattedText(w,'PRACTICE TRIAL',[],[],exptdesign.fixation.colour2);                    [VBLTimestamp]=Screen('Flip', window, VBLTimestamp+0.08);                end                                            case 'noflicker'                                        end                % clear screen (get rid of fixation after flicker so screen is blank        % for 0.5 s before stim onset)        Screen('FillRect',w, grey); % fill next buffer with uniform grey        DrawFormattedText(w,'PRACTICE TRIAL',[],[],exptdesign.fixation.colour2);        [VBLTimestamp ]=Screen('Flip', w);                if ( GetSecs-VBLTimestamp > params.timing.fixPntOffset )            disp('fixation offset error') % record error here        end                while (GetSecs-VBLTimestamp < params.timing.fixPntOffset)        end                vbl = GetSecs;                vblendtime = vbl + curDuration;        i=0;        dir = (round(rand)); % 1 is right, 0 is left.                % Animationloop:        while(vbl < vblendtime)            DrawFormattedText(w,'PRACTICE TRIAL',[],[],exptdesign.fixation.colour2);            % Shift the grating by "shiftperframe" pixels per frame:            xoffset = dir*ppc+((-1)^dir)*mod(i*shiftperframe,ppc);            %             xoffset = mod(i*shiftperframe,ppc);            i = i+1;                        % Define shifted srcRect that cuts out the properly shifted rectangular            % area from the texture:            srcRect=[xoffset 0 xoffset + visiblesize visiblesize];                        % Draw grating texture,:            Screen('DrawTexture', w, PRGrTexture, srcRect, dstRect, params.stimulus.angle);                        % Draw gaussian mask over grating: We need to subtract 0.5 from            % the real size to avoid interpolation artifacts that are            % created by the gfx-hardware due to internal numerical            % roundoff errors when drawing rotated images:            Screen('DrawTexture', w,   gab_MskTexture, [0 0 visiblesize visiblesize], dstRect, params.stimulus.angle);                        %DrawFormattedText(w,'PRACTICE TRIAL',[],[],exptdesign.fixation.colour2);            % Flip 'waitframes' monitor refresh intervals after last redraw.            vbl = Screen('Flip', w, vbl + (waitframes - 0.5) * scrinfo.ifi);                    end                % after stim offset, maintain blank screen for 0.25 s                Screen('FillRect',w, grey); % fill next buffer with uniform grey        DrawFormattedText(w,'PRACTICE TRIAL',[],[],exptdesign.fixation.colour2);        %Screen('DrawTexture', w, exptdesign.fixationWhite);        [VBLTimestamp ]=Screen('Flip', w);                        if params.stimulus.angle == 0 % right left                        % draw the response window            L(1) = center(1) - TxtSizeDiv2 - 100;            R(1) = center(1) + 100;            L(2) = center(2) - TxtSizeDiv2;            R(2) = center(2) - TxtSizeDiv2;                        DrawFormattedText(w,'PRACTICE TRIAL',[],[],exptdesign.fixation.colour2);            Screen('DrawText', w, 'R', R(1), R(2),black);            Screen('DrawText', w, 'L', L(1), L(2),black);        elseif params.stimulus.angle == 90 % up down                        % draw the response window            U(2) = center(2) - 100;            D(2) = center(2) - TxtSizeDiv2 + 100;            U(1) = center(1) - TxtSizeDiv2;            D(1) = center(1) - TxtSizeDiv2;                        DrawFormattedText(w,'PRACTICE TRIAL',[],[],exptdesign.fixation.colour2);            Screen('DrawText', w, 'U', U(1), U(2),black);            Screen('DrawText', w, 'D', D(1), D(2),black);        end                while (GetSecs-VBLTimestamp < params.timing.stimOffRespOn)        end                DrawFormattedText(w, '?', exptdesign.fixation.xloc, exptdesign.fixation.yloc, exptdesign.fixation.colour2);        DrawFormattedText(w,'PRACTICE TRIAL',[],[],exptdesign.fixation.colour2);        VBLTimestamp = Screen('Flip', w); % draw response screen                % get response key        correct=-1;        gotresponse=0;        startrt = VBLTimestamp;        while (gotresponse==0)            [~, endrt, KeyCode] = KbCheck;            if (KeyCode(responseKeys(1)) == 1) || (KeyCode(responseKeys(2)) == 1)                gotresponse = 1;            elseif KeyCode(escapeKey)==1                ABORTEDDATA=1;                quitflag = 1;                gotresponse=1;                break            end        end                        if ABORTEDDATA==0            if KeyCode(responseKeys(1))==1                correct = dir == 0; %KeyCode(responseKeys(1));            elseif KeyCode(responseKeys(2))==1                correct = dir == 1; %KeyCode(responseKeys(2));            end                        if correct                PsychPortAudio('FillBuffer', pahandle, corrsnd);            else                PsychPortAudio('FillBuffer', pahandle, wrongsnd);            end            PsychPortAudio('start', pahandle, [], 1);        end                Screen('FillRect',w, grey); % fill next buffer with uniform grey        Screen('DrawTexture', w, exptdesign.fixationBlack);        DrawFormattedText(w,'PRACTICE TRIAL',[],[],exptdesign.fixation.colour2);        Screen('Flip', w); %                if(correct)            curDuration = curDuration / 1.2;            PRcontrast = min(params.stimulus.contrast); %round(PRcontrast / 1.2, 2);            practicetrial=practicetrial+1; % increment trial counter        else            curDuration=curDuration*1.2;            PRcontrast = max(params.stimulus.contrast); %PRcontrast;%*1.2;            practicetrial=practicetrial; % do not increment trial counter        end            end % while        if params.practice.numtrials > 0        mytext = ['Practice trials complete.\nFor the actual experiment, the stimulus will be on the screen very briefly.\nDo you have any questions?\nWhen ready, press any button to begin the experiment.'];        DrawFormattedText(w,mytext, aes.align, 'center', 0, aes.txtwrapsize, [],[],aes.txtspacing);        Screen('Flip', w);        FlushEvents('keyDown');        WaitSecs(0.5)        KbWait()    end        Screen('FillRect',w, grey); % fill next buffer with uniform grey    mytext = ['Beginning experiment...'];    DrawFormattedText(w,mytext, aes.align, 'center', 0, aes.txtwrapsize, [],[],aes.txtspacing);    Screen('Flip', w);    WaitSecs(2);        Screen('DrawTexture', w, exptdesign.fixationBlack);    [VBLTimestamp]=Screen('Flip', w);        %% Do real trials        alldone=0;    curtrial=1;    quitflag = 0;    ABORTEDDATA=0;    startrt = 0;    while ((alldone==0)&&(quitflag==0))                trialStartTime=GetSecs; % mark the start of the trial%                % break removed by AH        %     if curtrial == params.takebreaktrial        %         takeabreaktext = 'Please take a short break. \n\n Press SPACE BAR when you are ready to continue.';        %         DrawFormattedText(w, takeabreaktext, 'center', 'center')        %         [VBLTimestamp]=Screen('Flip', w);        %         theKey=pbGetKey(spaceBar,responseKeyboard);        %     end                % do this at beginning of each trial to avoid massive chunks (and        % therefore potential delays) mid-trial        if eegConnect>0            [~, lsltime] = muselsl.inlet.pull_chunk;        end                        % Set up Dependent Variable level        switch params.procedure                        case 'interleaved'                                gotone=0;                while(gotone==0)                    scID=randomcondition(numStaircases); % randomly select a staircase                    if (~psyfuncfinished(screc(scID)))                        gotone=1;                    end                end % while                curStimLevel=psyfuncGetValue(screc(scID)); % get the duration from the current staircase record                            case 'Quest+'                                scID=0;                                curEz = screc.ScOrEz(curtrial);                                if curEz                    curStimLevelDb = screc.ezcond;                    curStimLevel = db2contrast(curStimLevelDb);                else                    curStimLevelDb = qpQuery(screc.questData);                    curStimLevel = db2contrast(curStimLevelDb);                end        end                curDuration=curStimLevel*ifi;                MaxPriority(w);                % Translate requested speed of the grating (in cycles per second)        % into a shift value in "pixels per frame", assuming given        % waitduration: This is the amount of pixels to shift our "aperture" at        % each redraw:        shiftperframe = pixelspersecond * waitduration;                %RANDOMIZE PHASE                RPhase1 = 2*pi*rand*ppc;                % wait until the start of the trial        while (GetSecs-trialStartTime < params.timing.intertrial)        end                Screen('DrawTexture', w, exptdesign.fixationBlack);        [VBLTimestamp]=Screen('Flip', w);                switch exptdesign.trialStartMode                        case 'flicker'                                % flicker fixation + for 2 cycles at 20 hz                flickerstart = VBLTimestamp+0.08;                for kk = 1:exptdesign.fixation.numflick                    Screen('DrawTexture', w, exptdesign.fixationBlack);                    [VBLTimestamp]=Screen('Flip', window, VBLTimestamp+0.08);                    Screen('DrawTexture', w, exptdesign.fixationWhite);                    [VBLTimestamp]=Screen('Flip', window, VBLTimestamp+0.08);                end                                if (eegConnect==1)                    muselsl.outlet.push_sample({museflags.e1_trial}, flickerstart);                end                            case 'noflicker'                                if (eegConnect==1)                    muselsl.outlet.push_sample({museflags.e1_trial}, VBLTimestamp);                end                        end                % clear screen (get rid of fixation after flicker so screen is blank        % for 0.5 s before stim onset)        Screen('FillRect',w, grey); % fill next buffer with uniform grey        [VBLTimestamp ]=Screen('Flip', w);                if ( GetSecs-VBLTimestamp > params.timing.fixPntOffset )            disp('fixation offset error') % record error here        end                while (GetSecs-VBLTimestamp < params.timing.fixPntOffset)        end                vbl = GetSecs;                vblendtime = vbl + curDuration;        i=0;        dir = (round(rand)); % 1 is right, 0 is left.                % Animationloop:        gotresponse=0;        startrt = vbl + (waitframes - 0.5) * ifi;        while(vbl < vblendtime)                        % Shift the grating by "shiftperframe" pixels per frame:            xoffset = dir*ppc+((-1)^dir)*mod(i*shiftperframe+RPhase1,ppc);            % xoffset = mod(i*shiftperframe,ppc);            i = i+1;                        % Define shifted srcRect that cuts out the properly shifted rectangular            % area from the texture:            srcRect=[xoffset 0 xoffset + visiblesize visiblesize];                        % Draw grating texture,:            Screen('DrawTexture', w, GrTexture, srcRect, dstRect, params.stimulus.angle);                        % Draw gaussian mask over grating: We need to subtract 0.5 from            % the real size to avoid interpolation artifacts that are            % created by the gfx-hardware due to internal numerical            % roundoff errors when drawing rotated images:            Screen('DrawTexture', w, gab_MskTexture, [0 0 visiblesize visiblesize], dstRect, params.stimulus.angle);                        % Flip 'waitframes' monitor refresh intervals after last redraw.            vbl = Screen('Flip', w, vbl + (waitframes - 0.5) * ifi);                        if i==1 && eegConnect==1                muselsl.outlet.push_sample({[museflags.e2_stim{dir+1,params.curBlock},'_',num2str(curStimLevel)]}, vbl);            end                        if gotresponse == 0                [~, secs, KeyCode] = KbCheck;                if (KeyCode(responseKeys(1)) == 1) || (KeyCode(responseKeys(2)) == 1)                    gotresponse = 1;                    endrt = secs;                elseif KeyCode(escapeKey)==1                    endrt = secs;                    ABORTEDDATA=1;                    gotresponse=1;                end            end                    end                Screen('FillRect',w, grey); % fill next buffer with uniform grey        %Screen('DrawTexture', w, exptdesign.fixationWhite);        [VBLTimestamp ]=Screen('Flip', w);                        if gotresponse==0            if params.stimulus.angle == 0 % right left                                % draw the response window                L(1) = center(1) - TxtSizeDiv2 - 100;                R(1) = center(1) + 100;                L(2) = center(2) - TxtSizeDiv2;                R(2) = center(2) - TxtSizeDiv2;                                Screen('DrawText', w, 'R', R(1), R(2),black);                Screen('DrawText', w, 'L', L(1), L(2),black);            elseif params.stimulus.angle == 90 % up down                                % draw the response window                U(2) = center(2) - 100;                D(2) = center(2) - TxtSizeDiv2 + 100;                U(1) = center(1) - TxtSizeDiv2;                D(1) = center(1) - TxtSizeDiv2;                                Screen('DrawText', w, 'U', U(1), U(2),black);                Screen('DrawText', w, 'D', D(1), D(2),black);            end        end                while (GetSecs-VBLTimestamp < params.timing.stimOffRespOn)            if gotresponse == 0                [~, secs, KeyCode] = KbCheck;                if (KeyCode(responseKeys(1)) == 1) || (KeyCode(responseKeys(2)) == 1)                    endrt = secs;                    gotresponse = 1;                elseif KeyCode(escapeKey)==1                    endrt = secs;                    ABORTEDDATA=1;                    gotresponse=1;                end            end        end                if gotresponse==0            DrawFormattedText(w, '?', exptdesign.fixation.xloc, exptdesign.fixation.yloc, exptdesign.fixation.colour2);            Screen('Flip', w); % draw response screen            [~, secs, KeyCode] = KbCheck;            if (KeyCode(responseKeys(1)) == 1) || (KeyCode(responseKeys(2)) == 1)                endrt = secs;                gotresponse = 1;            elseif KeyCode(escapeKey)==1                endrt = secs;                ABORTEDDATA=1;                gotresponse=1;                break            end        end                % get response key        %correct=-1;        %gotresponse=0;        %startrt = VBLTimestamp;        while (gotresponse==0)            [~, secs, KeyCode] = KbCheck;            if (KeyCode(responseKeys(1)) == 1) || (KeyCode(responseKeys(2)) == 1)                endrt = secs;                gotresponse = 1;            elseif KeyCode(escapeKey)==1                endrt = secs;                ABORTEDDATA=1;                gotresponse=1;                break            end        end                respLocation=0;        if ABORTEDDATA==0            if KeyCode(responseKeys(1))==1                correct = dir == 0; % 0 is left  %KeyCode(responseKeys(1));                respLocation = 1;                respLocTxt = 'left';            elseif KeyCode(responseKeys(2))==1                correct = dir == 1; % 1 is right %KeyCode(responseKeys(2));                respLocation = 2;                respLocTxt = 'right';            end                        if eegConnect==1                muselsl.outlet.push_sample({[museflags.e3_resp{correct+1},'_',respLocTxt]}, endrt);            end                                    if correct                PsychPortAudio('FillBuffer', pahandle, corrsnd);            else                PsychPortAudio('FillBuffer', pahandle, wrongsnd);            end            PsychPortAudio('start', pahandle, [], 1);                                            end                rt = endrt - startrt;        data(curtrial, :) = [cursizedeg curSFcpd curGaussSD dir respLocation scID curDuration correct rt];                Screen('FillRect',w, grey); % fill next buffer with uniform grey        Screen('DrawTexture', w, exptdesign.fixationBlack);        Screen('Flip', w); %                if ABORTEDDATA==1            quitflag=1;            break                    else                        if strcmp(params.procedure, 'interleaved')                tmpdone=1;                for kk=1:numStaircases                    if ~psyfuncfinished(screc(kk))                        tmpdone=0;                        break;                    end % if                end % for kk      checks all staircases, sets alldone to 1 if all sc are done                alldone=tmpdone;                            elseif strcmp(params.procedure, 'Quest+')                                response = correct+1; % needs to be 1 (wrong) and 2 (correct) for quest+                screc.questData = qpUpdate(screc.questData, curStimLevelDb, response);            end            curtrial=curtrial+1; % increment trial counter                        alldone = curtrial > params.nTrials;                    end            end % while        PsychPortAudio('Close'); % close the sound channel            if params.curBlock == params.numconds || ABORTEDDATA==1        Screen('DrawText', w, 'Thank you for your participation! ', 100,100, black);        Screen('Flip', w); %    end        %WaitSecs(5);        catch    % This "catch" section executes in case of an error in the "try" section    % above.  Importantly, it closes the onscreen window if it's open.    save CenSurr_crash.mat    Screen('CloseAll');    rethrow(lasterror);endreturn;